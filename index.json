[{"content":"\r\n\r\n**Java基础问题**\r\n\r\n\u003ca href=\"http://blog.csdn.net/zengshunyao/article/details/40023577\" target=\"_blank\" \u003eString的'+'的性能及原理\u003c/a\u003e\r\n\r\n\u003ca href=\"http://dylanxu.iteye.com/blog/1322066\" target=\"_blank\" \u003ejava之yield(),sleep(),wait()区别详解-备忘笔记\u003c/a\u003e\r\n\r\n\u003ca href=\"http://www.importnew.com/24235.html\" target=\"_blank\" \u003e深入理解Java Stream流水线\u003c/a\u003e\r\n\r\n\u003ca href=\"http://www.cnblogs.com/chendifan/p/6535590.html\" target=\"_blank\" \u003e抽象 \u0026amp; abstract关键字\u003c/a\u003e\r\n\r\n\u003ca href=\"http://www.jb51.net/article/93064.htm\" target=\"_blank\" \u003eJava final 修饰符知识点总结(必看篇)\u003c/a\u003e\r\n\r\n\u003ca href=\"http://www.cnblogs.com/starhu/p/5150241.html\" target=\"_blank\" \u003eJava中的static关键字解析\u003c/a\u003e\r\n\r\n\u003ca href=\"https://mp.weixin.qq.com/s/EGoKe-mIRTNDsSeLGzzUaA\" target=\"_blank\" \u003eJava 回调机制解读\u003c/a\u003e\r\n\r\n\u003ca href=\"http://mp.weixin.qq.com/s/VQFrCU_etJE6dyyQf6yUmQ\" target=\"_blank\" \u003eJava抽象类与oop三大特征\u003c/a\u003e\r\n\r\n\u003ca href=\"http://www.cnblogs.com/mstk/p/5511057.html\" target=\"_blank\" \u003eJava时间和时间戳的相互转换\u003c/a\u003e\r\n\r\n\u003ca href=\"http://blog.csdn.net/yu422560654/article/details/7466260\" target=\"_blank\" \u003eJava为什么要使用内部类？\u003c/a\u003e\r\n\r\n\u003ca href=\"http://blog.csdn.net/cs408/article/details/48930803\" target=\"_blank\" \u003eSynchronized（对象锁）和Static Synchronized（类锁）的区别\u003c/a\u003e\r\n\r\n\u003ca href=\"http://blog.csdn.net/lixungogogo/article/details/52226501\" target=\"_blank\" \u003eselect，poll，epoll优缺点及比较\u003c/a\u003e\r\n\r\n\u003ca href=\"http://www.cnblogs.com/chenssy/p/3388487.html\" target=\"_blank\" \u003ejava提高篇(八)----详解内部类\u003c/a\u003e\r\n\r\n\u003ca href=\"http://jjhpeopl.iteye.com/blog/2331054\" target=\"_blank\" \u003e单例模式和双重检查锁定\u003c/a\u003e\r\n\r\n\u003ca href=\"http://www.cnblogs.com/TalkWithWorld/p/5641169.html\" target=\"_blank\" \u003ejava中实现多态的机制是什么?\u003c/a\u003e\r\n\r\n\u003ca href=\"http://www.cnblogs.com/chenssy/p/3372798.html\" target=\"_blank\" \u003ejava提高篇(四)-----理解java的三大特性之多态\u003c/a\u003e\r\n\r\n\u003ca href=\"http://www.tuicool.com/articles/mMN3Iz\" target=\"_blank\" \u003ejava类静态域、块，非静态域、块，构造函数的初始化顺序\u003c/a\u003e\r\n\r\n\u003ca href=\"http://www.codeceo.com/article/why-java-string-immutable.html\" target=\"_blank\" \u003eJava 中的 String 为什么是不可变的？\u003c/a\u003e\r\n\r\n\u003ca href=\"http://www.jb51.net/article/49092.htm\" target=\"_blank\" \u003eJava的string类为什么是不可变的\u003c/a\u003e\r\n\r\n\u003ca href=\"http://blog.csdn.net/sunxianghuang/article/details/51982979\" target=\"_blank\" \u003eJava泛型深入理解\u003c/a\u003e\r\n\r\n\u003ca href=\"http://blog.csdn.net/fgakjfd/article/details/5282646\" target=\"_blank\" \u003e静态内部类和非静态内部类的区别\u003c/a\u003e\r\n\r\n\u003ca href=\"http://mp.weixin.qq.com/s%3F__biz%3DMzIzMjE1Njg4Mw%3D%3D%26mid%3D502634028%26idx%3D1%26sn%3D29890f04d6d27764a4dc7698ce0ccdce%23rd\" target=\"_blank\" \u003e十分钟理解Java中的弱引用\u003c/a\u003e\r\n\r\n\u003chr\u003e\r\n\r\n\u003ch3 class=\"heading\" data-id=\"heading-1\"\u003e\u003cstrong\u003e底层原理（JVM、JMM、Java源码、并发等）\u003c/strong\u003e\u003c/h3\u003e\u003ca href=\"http://www.importnew.com/24231.html\" target=\"_blank\" \u003eJVM如何操作缓冲区\u003c/a\u003e\r\n\r\n\u003ca href=\"http://www.cnblogs.com/wozixiaoyao/p/5658960.html\" target=\"_blank\" \u003e成为Java GC专家（3）—如何优化Java垃圾回收机制\u003c/a\u003e\r\n\r\n\u003ca href=\"http://uule.iteye.com/blog/2114697\" target=\"_blank\" \u003eJVM性能调优（重要）\u003c/a\u003e\r\n\r\n\u003ca href=\"http://www.importnew.com/20386.html\" target=\"_blank\" \u003eJava8系列之重新认识HashMap\u003c/a\u003e\r\n\r\n\u003ca href=\"http://www.cnblogs.com/shishm/archive/2011/10/10/2205743.html\" target=\"_blank\" \u003e解读克隆\u003c/a\u003e\r\n\r\n\u003ca href=\"http://elim.iteye.com/blog/1523785\" target=\"_blank\" \u003e如何正确遍历删除List中的元素，你会吗？\u003c/a\u003e\r\n\r\n\u003ca href=\"https://my.oschina.net/mfkwfc/blog/60441\" target=\"_blank\" \u003ekeySet和entrySet效率比较\u003c/a\u003e\r\n\r\n\u003ca href=\"http://blog.csdn.net/xuxurui007/article/details/7685076\" target=\"_blank\" \u003eThread的run（）与start（）的区别\u003c/a\u003e\r\n\r\n\u003ca href=\"http://blog.csdn.net/aesop_wubo/article/details/7574379\" target=\"_blank\" \u003eJAVA并发编程学习笔记之ReentrantLock\u003c/a\u003e\r\n\r\n\u003ca href=\"http://blog.csdn.net/hackbuteer1/article/details/6789164\" target=\"_blank\" \u003e百度笔试题：malloc/free与new/delete的区别\u003c/a\u003e\r\n\r\n\u003ca href=\"http://www.jianshu.com/p/b54f1df33f84%23\" target=\"_blank\" \u003eJAVA集合框架中的常用集合及其特点、适用场景、实现原理简介\u003c/a\u003e\r\n\r\n\u003ca href=\"http://blog.csdn.net/aesop_wubo/article/details/7574379\" target=\"_blank\" \u003eJAVA并发编程学习笔记之ReentrantLock\u003c/a\u003e\r\n\r\n\u003ca href=\"http://www.jb51.net/article/112721.htm\" target=\"_blank\" \u003e详解Java中LinkedHashMap\u003c/a\u003e\r\n\r\n\u003ca href=\"http://www.cnblogs.com/zhangygl/p/4298113.html\" target=\"_blank\" \u003e请求Servlet流程以及Servlet生命周期\u003c/a\u003e\r\n\r\n\u003ca href=\"http://blog.csdn.net/pi9nc/article/details/12374049\" target=\"_blank\" \u003ejava finalize方法总结、GC执行finalize的过程\u003c/a\u003e\r\n\r\n\u003ca href=\"http://www.cnblogs.com/redcreen/archive/2011/05/04/2037057.html\" target=\"_blank\" \u003eJVM系列三:JVM参数设置、分析\u003c/a\u003e\r\n\r\n\u003ca href=\"https://my.oschina.net/polly/blog/877647\" target=\"_blank\" \u003eJava泛型总结\u003c/a\u003e\r\n\r\n\u003ca href=\"http://developer.51cto.com/art/201403/432095.htm\" target=\"_blank\" \u003eJava并发之CountDownLatch、CyclicBarrier和Semaphore\u003c/a\u003e\r\n\r\n\u003ca href=\"http://tomyz0223.iteye.com/blog/1035686\" target=\"_blank\" \u003e使用LinkedHashMap构建LRU的Cache\u003c/a\u003e\r\n\r\n\u003ca href=\"http://www.importnew.com/23610.html\" target=\"_blank\" \u003e谈谈ConcurrentHashMap1.7和1.8的不同实现\u003c/a\u003e\r\n\r\n\u003ca href=\"http://www.cnblogs.com/beatIteWeNerverGiveUp/p/5709841.html\" target=\"_blank\" \u003eHashMap底层实现原理/HashMap与HashTable区别/HashMap与HashSet区别\u003c/a\u003e\r\n\r\n\u003ca href=\"http://www.cnblogs.com/zhujiabin/p/5404771.html\" target=\"_blank\" \u003eJava 四种线程池\u003c/a\u003e\r\n\r\n\u003ca href=\"http://blog.csdn.net/luckydog1991/article/details/51718663\" target=\"_blank\" \u003eJDK与设计模式：命令模式\u003c/a\u003e\r\n\r\n\u003ca href=\"http://blog.jobbole.com/62314/\" target=\"_blank\" \u003e细数JDK里的设计模式\u003c/a\u003e\r\n\r\n\u003ca href=\"http://www.cnblogs.com/ChaosJu/p/4531795.html\" target=\"_blank\" \u003ejava多线程(二)——用到的设计模式\u003c/a\u003e\r\n\r\n\u003ca href=\"http://blog.csdn.net/zhangliangzi/article/details/52389766\" target=\"_blank\" \u003eJava并发核心基础——线程池使用及底层实现机制详解\u003c/a\u003e\r\n\r\n\u003ca href=\"http://www.cnblogs.com/damsoft/p/6105122.html\" target=\"_blank\" \u003e单例模式的优缺点和使用场景\u003c/a\u003e\r\n\r\n\u003ca href=\"http://blog.csdn.net/do_smile/article/details/46911727\" target=\"_blank\" \u003eJava 8 中的ConcurrentHashMap源码分析\u003c/a\u003e\r\n\r\n\u003ca href=\"http://blog.csdn.net/xiaoyi52/article/details/68931308\" target=\"_blank\" \u003e线程池\u003c/a\u003e\r\n\r\n\u003chr\u003e\r\n\r\n\u003ch3 class=\"heading\" data-id=\"heading-2\"\u003e\u003cstrong\u003e框架类问题（Spring、SpringMVC、Mybatis等）\u003c/strong\u003e\u003c/h3\u003e\u003ca href=\"http://www.importnew.com/24305.html\" target=\"_blank\" \u003eSpring AOP的实现原理\u003c/a\u003e\r\n\r\n\u003ca href=\"http://www.tuicool.com/articles/6JjyArv\" target=\"_blank\" \u003egit干货系列：（三）我提交错了我想撤销或者回退版本\u003c/a\u003e\r\n\r\n\u003ca href=\"http://blog.csdn.net/lmy86263/article/details/51724221\" target=\"_blank\" \u003eJava Web应用中支持跨域请求\u003c/a\u003e\r\n\r\n\u003ca href=\"http://ifeve.com/spring-interview-questions-and-answers/\" target=\"_blank\" \u003e69道Spring面试题和答案\u003c/a\u003e\r\n\r\n\u003ca href=\"http://www.codeceo.com/article/spring-transactions.html\" target=\"_blank\" \u003e深入理解 Spring 事务原理\u003c/a\u003e\r\n\r\n\u003ca href=\"http://www.mamicode.com/info-detail-1248286.html\" target=\"_blank\" \u003eSpring事务管理（详解+实例）\u003c/a\u003e\r\n\r\n\u003ca href=\"http://www.importnew.com/24160.html\" target=\"_blank\" \u003eMyBatis动态SQL底层原理分析\u003c/a\u003e\r\n\r\n\u003ca href=\"http://blog.csdn.net/justloveyou_/article/details/74295728\" target=\"_blank\" \u003e简述Spring容器与SpringMVC的容器的联系与区别\u003c/a\u003e\r\n\r\n\u003ca href=\"http://blog.csdn.net/moreevan/article/details/11977115/\" target=\"_blank\" \u003eSpring AOP 实现原理\u003c/a\u003e\r\n\r\n\u003ca href=\"http://www.cnblogs.com/leirenyuan/p/6016063.html\" target=\"_blank\" \u003ejsp 九大内置对象和其作用详解\u003c/a\u003e\r\n\r\n\u003ca href=\"https://www.ibm.com/developerworks/cn/xml/x-sisoap/\" target=\"_blank\" \u003e浅谈 SOAP\u003c/a\u003e\r\n\r\n\u003ca href=\"http://www.cnblogs.com/songshu120/p/6164114.html\" target=\"_blank\" \u003eMaven如何解决包冲突问题\u003c/a\u003e\r\n\r\n\u003ca href=\"http://blog.csdn.net/xpsharp/article/details/47156197\" target=\"_blank\" \u003emaven中如何将所有引用的jar包打包到一个jar中\u003c/a\u003e\r\n\r\n\u003ca href=\"http://mp.weixin.qq.com/s/nFdjgTrVrI0q90fZFUxm2w\" target=\"_blank\" \u003eMyBatis 拦截器原理探究\u003c/a\u003e\r\n\r\n\u003ca href=\"http://blog.csdn.net/wguoyong/article/details/51009572\" target=\"_blank\" \u003eTomcat负载均衡原理详解及配置\u003c/a\u003e\r\n\r\n\u003ca href=\"http://2277259257.iteye.com/blog/2300298\" target=\"_blank\" \u003eSpringMVC一个Controller处理所有用户请求的并发问题\u003c/a\u003e\r\n\r\n\u003chr\u003e\r\n\r\n\u003ch3 class=\"heading\" data-id=\"heading-3\"\u003e\u003cstrong\u003e算法问题\u003c/strong\u003e\u003c/h3\u003e\u003ca href=\"http://blog.csdn.net/semiscone/article/details/52775382\" target=\"_blank\" \u003eAVL树、红黑树、B/B+树和Trie树的比较\u003c/a\u003e\r\n\r\n\u003ca href=\"http://blog.csdn.net/jiaomeng/article/details/1495500\" target=\"_blank\" \u003eBloom Filter概念和原理\u003c/a\u003e\r\n\r\n\u003ca href=\"http://blog.csdn.net/u013271921/article/details/45540749\" target=\"_blank\" \u003e双向链表的插入及删除图解\u003c/a\u003e\r\n\r\n\u003ca href=\"http://blog.csdn.net/llingy/article/details/5674250\" target=\"_blank\" \u003e搜索算法集锦\u003c/a\u003e\r\n\r\n\u003ca href=\"http://www.cnblogs.com/tgycoder/p/5077017.html\" target=\"_blank\" \u003e关于B树的一些总结\u003c/a\u003e\r\n\r\n\u003ca href=\"http://www.jb51.net/article/54774.htm\" target=\"_blank\" \u003eRedis中5种数据结构的使用场景介绍\u003c/a\u003e\r\n\r\n\u003ca href=\"http://www.cnblogs.com/xujian2014/p/5614724.html\" target=\"_blank\" \u003e字典树(Trie树)实现与应用\u003c/a\u003e\r\n\r\n\u003ca href=\"http://www.cnblogs.com/hapjin/p/5783536.html\" target=\"_blank\" \u003e实现一个 能在O(1)时间复杂度 完成 Push、Pop、Min操作的栈\u003c/a\u003e\r\n\r\n\u003ca href=\"http://blog.csdn.net/forezp/article/details/67632323\" target=\"_blank\" \u003e常见的安全算法\u003c/a\u003e\r\n\r\n\u003ca href=\"http://blog.csdn.net/alburthoffman/article/details/18803357\" target=\"_blank\" \u003e面试题：支持O(1)时间内完成pop,push和max的栈\u003c/a\u003e\r\n\r\n\u003ca href=\"http://blog.csdn.net/v_july_v/article/details/7382693\" target=\"_blank\" \u003e教你如何迅速秒杀掉：99%的海量数据处理面试题\u003c/a\u003e\r\n\r\n\u003ca href=\"http://www.cnblogs.com/BrainDeveloper/p/3192417.html\" target=\"_blank\" \u003e单例模式应用场景\u003c/a\u003e\r\n\r\n\u003ca href=\"http://blog.csdn.net/cywosp/article/details/23397179/\" target=\"_blank\" \u003e每天进步一点点——五分钟理解一致性哈希算法(consistent hashing)\u003c/a\u003e\r\n\r\n\u003ca href=\"http://www.cnblogs.com/youngerchina/p/5624460.html\" target=\"_blank\" \u003e为什么说B+-tree比B 树更适合实际应用中操作系统的文件索引和数据库索引？\u003c/a\u003e\r\n\r\n\u003ca href=\"http://www.cnblogs.com/ccsccs/articles/4243644.html\" target=\"_blank\" \u003eB+树\u003c/a\u003e\r\n\r\n\u003chr\u003e\r\n\r\n\u003ch3 class=\"heading\" data-id=\"heading-4\"\u003e\u003cstrong\u003e基础课程（数据库、计算机网络、计算机组成原理、操作系统等）\u003c/strong\u003e\u003c/h3\u003e\u003ca href=\"http://blog.csdn.net/u011225629/article/details/47393169\" target=\"_blank\" \u003e高并发访问数据库优化方法\u003c/a\u003e\r\n\r\n\u003ca href=\"http://blog.csdn.net/jenminzhang/article/details/47017741\" target=\"_blank\" \u003e简单理解Socket及TCP/IP、Http、Socket的区别\u003c/a\u003e\r\n\r\n\u003ca href=\"http://www.cnblogs.com/shijingjing07/p/5611579.html\" target=\"_blank\" \u003e虚拟内存机制\u003c/a\u003e\r\n\r\n\u003ca href=\"http://www.cnblogs.com/yep3575/p/3491039.html\" target=\"_blank\" \u003e几种网络I/O模型\u003c/a\u003e\r\n\r\n\u003ca href=\"http://www.cnblogs.com/rollenholt/archive/2012/03/23/2414345.html\" target=\"_blank\" \u003e从输入url到显示网页，后台发生了什么？\u003c/a\u003e\r\n\r\n\u003ca href=\"http://news.mydrivers.com/1/372/372665.htm\" target=\"_blank\" \u003e网页打开时都发生了什么？我被吓着了\u003c/a\u003e\r\n\r\n\u003ca href=\"http://smalltalllong.iteye.com/blog/1156407\" target=\"_blank\" \u003e线程返回值的方式介绍\u003c/a\u003e\r\n\r\n\u003ca href=\"http://www.cnblogs.com/zimmer/p/4343632.html\" target=\"_blank\" \u003eSSL交互和握手过程\u003c/a\u003e\r\n\r\n\u003ca href=\"http://www.jianshu.com/p/5ad4a88e58d4%23\" target=\"_blank\" \u003eSQL学习笔记——之SQL优化经验总结34条\u003c/a\u003e\r\n\r\n\u003ca href=\"http://www.cnblogs.com/0201zcr/p/4694945.html\" target=\"_blank\" \u003eHTTP长连接和短连接\u003c/a\u003e\r\n\r\n\u003ca href=\"http://blog.csdn.net/wangqyoho/article/details/52598859\" target=\"_blank\" \u003e进程？线程？到底共享了什么私有了什么\u003c/a\u003e\r\n\r\n\u003ca href=\"http://blog.csdn.net/leshami/article/details/39829605\" target=\"_blank\" \u003eMySQL 慢查询日志(Slow Query Log)\u003c/a\u003e\r\n\r\n\u003ca href=\"http://blog.csdn.net/yusiguyuan/article/details/38984759\" target=\"_blank\" \u003eTCP/IP详解--TIME_WAIT状态存在的原因\u003c/a\u003e\r\n\r\n\u003ca href=\"http://blog.csdn.net/omenglishuixiang1234/article/details/51536771\" target=\"_blank\" \u003e操作系统：内存管理（概念）\u003c/a\u003e\r\n\r\n\u003ca href=\"http://blog.csdn.net/robinjwong/article/details/18502195/\" target=\"_blank\" \u003e从关系型数据库到非关系型数据库\u003c/a\u003e\r\n\r\n\u003ca href=\"http://blog.csdn.net/ws0513/article/details/49980547\" target=\"_blank\" \u003edrop、truncate和delete的区别\u003c/a\u003e\r\n\r\n\u003ca href=\"http://blog.csdn.net/sinat_36042530/article/details/52565296\" target=\"_blank\" \u003e线程的几种状态转换\u003c/a\u003e\r\n\r\n\u003ca href=\"http://blog.csdn.net/javazejian/article/details/69857949\" target=\"_blank\" \u003eMySQL的进阶实战篇\u003c/a\u003e\r\n\r\n\u003ca href=\"https://zhuanlan.zhihu.com/p/25064592\" target=\"_blank\" \u003e关于 MySQL 你可能不知道的 SQL 使用技巧\u003c/a\u003e\r\n\r\n\u003ca href=\"http://www.jb51.net/article/47419.htm\" target=\"_blank\" \u003eMySQL优化必须调整的10项配置\u003c/a\u003e\r\n\r\n\u003ca href=\"http://web.jobbole.com/91084/\" target=\"_blank\" \u003e浏览器缓存机制剖析\u003c/a\u003e\r\n\r\n\u003ca href=\"http://www.cnblogs.com/future2012lg/p/4873805.html\" target=\"_blank\" \u003eMySQL数据的主从复制、半同步复制和主主复制详解-转\u003c/a\u003e\r\n\r\n\u003ca href=\"http://blog.jobbole.com/1344/\" target=\"_blank\" \u003e8 种 NoSQL 数据库系统对比\u003c/a\u003e\r\n\r\n\u003ca href=\"http://www.cnblogs.com/Aiapple/p/5792939.html\" target=\"_blank\" \u003emysql 主从复制原理\u003c/a\u003e\r\n\r\n\u003ca href=\"http://wingjay.com/2017/04/09/Java%25E9%2587%258C%25E5%25A6%2582%25E4%25BD%2595%25E5%25AE%259E%25E7%258E%25B0%25E7%25BA%25BF%25E7%25A8%258B%25E9%2597%25B4%25E9%2580%259A%25E4%25BF%25A1%25EF%25BC%259F/\" target=\"_blank\" \u003eJava里如何实现线程间通信？\u003c/a\u003e\r\n\r\n\u003ca href=\"http://sunnylocus.iteye.com/blog/805855\" target=\"_blank\" \u003e理解多线程设计模式\u003c/a\u003e\r\n\r\n\u003chr\u003e\r\n\r\n\u003ch3 class=\"heading\" data-id=\"heading-5\"\u003e\u003cstrong\u003e其他\u003c/strong\u003e\u003c/h3\u003e\u003ca href=\"http://blog.csdn.net/h378588270/article/details/12912611\" target=\"_blank\" \u003egetAttribute与getParame的区别\u003c/a\u003e\r\n\r\n\u003ca href=\"http://blog.csdn.net/shaobingj126/article/details/50585035\" target=\"_blank\" \u003e大型网站架构之分布式消息队列\u003c/a\u003e\r\n\r\n\u003ca href=\"http://blog.csdn.net/heyutao007/article/details/50131089\" target=\"_blank\" \u003e消息队列的两种模式\u003c/a\u003e\r\n\r\n\u003ca href=\"http://blog.csdn.net/ljianhui/article/details/11100625/\" target=\"_blank\" \u003e初窥Linux 之 我最常用的20条命令\u003c/a\u003e\r\n\r\n\u003ca href=\"http://www.codeceo.com/article/common-performance-optimization-strategies.html\" target=\"_blank\" \u003e常见性能优化策略总结\u003c/a\u003e\r\n\r\n\u003ca href=\"http://blog.jobbole.com/30940/\" target=\"_blank\" \u003e缓存、缓存算法和缓存框架简介\u003c/a\u003e\r\n\r\n\u003ca href=\"http://www.importnew.com/24185.html\" target=\"_blank\" \u003e如何设计一个秒杀系统\u003c/a\u003e\r\n\r\n\u003ca href=\"http://www.importnew.com/24107.html\" target=\"_blank\" \u003eRedis初级介绍\u003c/a\u003e\r\n\r\n\u003ca href=\"http://www.cnblogs.com/leefreeman/p/3993449.html\" target=\"_blank\" \u003e大型网站系统架构的演化\u003c/a\u003e\r\n\r\n\u003ca href=\"http://lusongsong.com/reed/158.html\" target=\"_blank\" \u003e浅谈负载均衡技术与分类\u003c/a\u003e\r\n\r\n\u003ca href=\"http://www.oschina.net/news/77156/load-balance\" target=\"_blank\" \u003e一分钟了解负载均衡的一切\u003c/a\u003e\r\n\r\n\u003ca href=\"http://www.tuicool.com/articles/QFFjEr2\" target=\"_blank\" \u003e保证分布式系统数据一致性的6种方案\u003c/a\u003e\r\n\r\n","cover":"","link":"后端开发常问面试题集.html","preview":"","title":"后台开发常问面试题集"},{"content":"\r\n\r\n## 介绍｡◕ᴗ◕｡\r\n\r\n### 定义\r\n\r\n\u003e将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示\r\n\r\n### 作用\r\n\r\n用户只需要知道建造的类型就可以得到他们，而无需知道具体的建造过程和细节\r\n\r\n### 解决的问题\r\n\r\n* 方便用户创建复杂的对象（不需要知道实现过程）\r\n* 代码复用性、封装性（将对象构建过程和细节进行封装、复用\r\n\r\n## 模式说明\r\n\r\n### 1.UML类图\r\n\r\n![建造者模式](https://n1image.hjfile.cn/shetuan/2018-06-12-1528795791-509-5685.png)\r\n\r\n### 2.实例说明\r\n\r\n* 背景：用户输入不同的类型（1，2，3），输出不同的二维码分享图\r\n* 图例说明：如下图，穿插了两种产品（**Product**）—— 画直播间图（BaseDrawRoomImage）、画课程图（BaseDrawCourseImage）。两个都是继承自抽象接口AbstractDrawImage(提供画圆形、方形、字符串、计算字符串等通用方法)。\r\nBaseDrawRoomImage（**Builder**）下有具体的DrawLiveRoomImage 1 2 两个实现类（**ContractBuilder**）\r\nBaseDrawCourseImage（**Builder**）下有具体的DrawCourseImage 1 2 两个实现类（**ContractBuilder**）\r\nDrawDetector类(**Director**)为指挥者\r\n![图例](https://n1image.hjfile.cn/shetuan/2018-06-12-1528788783-023-3830.png)\r\n\r\n#### springboot 源码\r\n\r\n``` java\r\npublic abstract class AbstractDrawShareImage {\r\n\r\n    protected static final Logger LOGGER = LoggerFactory.getLogger(AbstractDrawShareImage.class);\r\n\r\n    protected BufferedImage baseImage;\r\n    protected Graphics2D g2d;\r\n\r\n    /**\r\n     * 画背景\r\n     */\r\n    public void drawBackgroudImage(String baseImagePathName) throws IOException {\r\n        Resource resource = new ClassPathResource(baseImagePathName);\r\n        this.baseImage = ImageIO.read(resource.getInputStream());\r\n        this.g2d = this.baseImage.createGraphics();\r\n    }\r\n\r\n\r\n    /**\r\n     * 画圆形\r\n     *\r\n     * @param imageUrl\r\n     * @param x\r\n     * @param y\r\n     * @param maxLength\r\n     */\r\n    public void drawCircularImage(String imageUrl, int x, int y, int maxLength) {\r\n        try {\r\n            BufferedImage image = ImageIO.read(new URL(imageUrl));\r\n            this.g2d.drawImage(ImageUtils.convertCircular(image, image.getWidth() \u003e maxLength ? maxLength : image.getWidth()).getScaledInstance(maxLength, maxLength, Image.SCALE_SMOOTH), x, y, null);\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 画矩形\r\n     *\r\n     * @param imageUrl\r\n     * @param x\r\n     * @param y\r\n     * @param length\r\n     * @param width\r\n     */\r\n    public void drawRectangle(String imageUrl, int x, int y, int length, int width) {\r\n        BufferedImage image = null;\r\n        try {\r\n            image = ImageIO.read(new URL(imageUrl));\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n        this.g2d.drawImage(image, x, y, width, length, null);\r\n    }\r\n    /**\r\n     * 画字符串\r\n     *\r\n     * @param text\r\n     * @param x\r\n     * @param y\r\n     * @param color\r\n     * @param font\r\n     */\r\n    public void drawString(String text, int x, int y, Color color, Font font) {\r\n        this.g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\r\n        this.g2d.setFont(font);\r\n        this.g2d.setColor(color);\r\n        this.g2d.drawString(text, x, y);\r\n    }\r\n\r\n    public int getFontWitch(Font font, int baseWidth, String text) {\r\n        if (StringUtils.isEmpty(text)) {\r\n            return 0;\r\n        }\r\n        // 计算文字长度，计算居中的x点坐标\r\n        return (baseWidth - getWordWidth(font, text)) / 2;\r\n    }\r\n\r\n    public int getWordWidth(Font font, String word) {\r\n        if (StringUtils.isEmpty(word)) {\r\n            return 0;\r\n        }\r\n        FontMetrics fm = this.g2d.getFontMetrics(font);\r\n        return fm.stringWidth(word);\r\n    }\r\n\r\n}\r\n\r\npublic abstract class BaseDrawRoomImage extends AbstractDrawShareImage {\r\n    protected int baseWidth = 0;\r\n    protected static final String TIME_TEXT = \"邀请卡有效期至\";\r\n\r\n    public abstract void drawBackgroudImage() throws IOException;\r\n\r\n    /**\r\n     * 画头像\r\n     *\r\n     * @param headUrl\r\n     */\r\n    public abstract void drawHeadImage(String headUrl);\r\n    /**\r\n     * 昵称\r\n     *\r\n     * @param nick\r\n     */\r\n    public abstract void drawNick(String nick);\r\n    /**\r\n     * 画二维码\r\n     *\r\n     * @param qrcodeUrl\r\n     */\r\n    public abstract void drawQrCode(String qrcodeUrl);\r\n    /**\r\n     * 画直播间名称\r\n     *\r\n     * @param roomName\r\n     */\r\n    public abstract void drawLiveRoomName(String roomName);\r\n    /**\r\n     * 画二维码有效日期文字\r\n     *\r\n     * @param expireText\r\n     */\r\n    public abstract void drawDeadline(String expireText);\r\n}\r\n\r\n\r\npublic class DrawLiveRoomImage1 extends BaseDrawRoomImage {\r\n   //具体 override 省略...\r\n}\r\n\r\n//具体建造，画头像、二维码、昵称、背景、过期时间\r\n@Component(\"DrawLearnImage\")\r\npublic  class DrawDerecter {\r\n    private AbstractDrawShareImage drawShareImage;\r\n    public Image drawImage(String headUrl, String nick, String roomName, String qrcodeUrl, String expireText) throws CustomerException {\r\n        if (drawShareImage instanceof BaseDrawRoomImage) {\r\n            BaseDrawRoomImage baseDrawRoomImage1 = (BaseDrawRoomImage) drawShareImage;\r\n            try {\r\n                baseDrawRoomImage1.drawBackgroudImage();\r\n            } catch (Exception e) {\r\n                BusinessException.throwCustomException(BusinessException.DRAW_LEARN_IMAGE_FAILED, \"image not fond\");\r\n            }\r\n\r\n            baseDrawRoomImage1.drawHeadImage(headUrl);\r\n            baseDrawRoomImage1.drawQrCode(qrcodeUrl);\r\n            baseDrawRoomImage1.drawLiveRoomName(roomName);\r\n            baseDrawRoomImage1.drawNick(nick);\r\n            baseDrawRoomImage1.drawDeadline(expireText);\r\n            baseDrawRoomImage1.g2d.dispose();\r\n\r\n            drawShareImage.g2d.dispose();\r\n            return baseDrawRoomImage1.baseImage;\r\n        }\r\n\r\n        BusinessException.throwCustomException(BusinessException.DRAW_LEARN_IMAGE_FAILED);\r\n        return null;\r\n    }\r\n}\r\n```\r\n\r\n### 优缺点\r\n\r\n#### 优点\r\n\r\n1. 易于解耦 \r\n将产品本身与产品创建过程进行解耦，可以使用相同的创建过程来得到不同的产品。也就说细节依赖抽象。\r\n2. 易于精确控制对象的创建将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰\r\n3. 易于拓展 \r\n增加新的具体建造者无需修改原有类库的代码，易于拓展，符合“开闭原则”。 \r\n*每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，用户使用不同的具体建造者即可得到不同的产品对象。*\r\n\r\n#### 缺点\r\n\r\n1. 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似；如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。\r\n2. 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。 \r\n\r\n### 最佳实践\r\n当创建复杂对象的算法独立于该对象的组成部分以及他们的装配方式时使用","cover":"https://images.pexels.com/photos/262367/pexels-photo-262367.jpeg?auto=compress\u0026cs=tinysrgb\u0026h=350","link":"设计模式：建造者模式.html","preview":"\u003cp\u003e将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示\u003c/p\u003e\n","title":"设计模式：建造者模式"},{"content":"\r\n\r\n转自[https://github.com/xingshaocheng/architect-awesome/blob/master/README.md](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md)\r\n\r\n\r\n\r\n\r\n# 数据结构\r\n\r\n## 队列\r\n* [《java队列——queue详细分析》](https://www.cnblogs.com/lemon-flm/p/7877898.html)\r\n\t* 非阻塞队列：ConcurrentLinkedQueue(无界线程安全)，采用CAS机制（compareAndSwapObject原子操作）。\r\n\t* 阻塞队列：ArrayBlockingQueue(有界)、LinkedBlockingQueue（无界）、DelayQueue、PriorityBlockingQueue，采用锁机制；使用 ReentrantLock 锁。\r\n\r\n* [《LinkedList、ConcurrentLinkedQueue、LinkedBlockingQueue对比分析》](https://www.cnblogs.com/mantu/p/5802393.html)\r\n\r\n## 集合\r\n* [《Java Set集合的详解》](https://blog.csdn.net/qq_33642117/article/details/52040345)\r\n\r\n## 链表、数组\r\n* [《Java集合详解--什么是List》](https://blog.csdn.net/wz249863091/article/details/52853360)\r\n\r\n## 字典、关联数组\r\n* [《Java map 详解 - 用法、遍历、排序、常用API等》](https://baike.xsoftlab.net/view/250.html)\r\n\r\n## 栈\r\n* [《java数据结构与算法之栈（Stack）设计与实现》](https://blog.csdn.net/javazejian/article/details/53362993)\r\n* [《Java Stack 类》](http://www.runoob.com/java/java-stack-class.html)\r\n* [《java stack的详细实现分析》](https://blog.csdn.net/f2006116/article/details/51375225)\r\n\t* Stack 是线程安全的。\r\n\t* 内部使用数组保存数据，不够时翻倍。\r\n\r\n## 树\r\n\r\n### 二叉树\r\n\r\n每个节点最多有两个叶子节点。\r\n*  [《二叉树》](https://blog.csdn.net/cai2016/article/details/52589952)\r\n\r\n### 完全二叉树\r\n* [《完全二叉树》](https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232?fr=aladdin)\r\n\t* 叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树。\r\n\r\n### 平衡二叉树\r\n左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。\r\n* [《浅谈数据结构-平衡二叉树》](http://www.cnblogs.com/polly333/p/4798944.html)\r\n* [《浅谈算法和数据结构: 八 平衡查找树之2-3树》](http://www.cnblogs.com/yangecnu/p/Introduce-2-3-Search-Tree.html)\r\n\r\n### 二叉查找树（BST）\r\n二叉查找树（Binary Search Tree），也称有序二叉树（ordered binary tree）,排序二叉树（sorted binary tree）。\r\n\r\n* [《浅谈算法和数据结构: 七 二叉查找树》](http://www.cnblogs.com/yangecnu/p/Introduce-Binary-Search-Tree.html)\r\n\r\n\r\n### 红黑树\r\n* [《最容易懂得红黑树》](https://blog.csdn.net/sun_tttt/article/details/65445754)\r\n\t* 添加阶段后，左旋或者右旋从而再次达到平衡。 \r\n* [《浅谈算法和数据结构: 九 平衡查找树之红黑树》](http://www.cnblogs.com/yangecnu/p/Introduce-Red-Black-Tree.html)\r\n\r\n### B-，B+，B*树\r\nMySQL是基于B+树聚集索引组织表\r\n\r\n* [《B-树，B+树，B\\*树详解》](https://blog.csdn.net/aqzwss/article/details/53074186)\r\n* [《B-树，B+树与B\\*树的优缺点比较》](https://blog.csdn.net/bigtree_3721/article/details/73632405)\r\n\t* B+ 树的叶子节点链表结构相比于 B- 树便于扫库，和范围检索。\r\n### LSM 树\r\n\r\nLSM（Log-Structured Merge-Trees）和 B+ 树相比，是牺牲了部分读的性能来换取写的性能(通过批量写入)，实现读写之间的。\r\nHbase、LevelDB、Tair（Long DB）、nessDB 采用 LSM 树的结构。LSM可以快速建立索引。\r\n\r\n* [《LSM树 VS B+树》](https://blog.csdn.net/dbanote/article/details/8897599)\r\n\t* B+ 树读性能好，但由于需要有序结构，当key比较分散时，磁盘寻道频繁，造成写性能。\r\n\t* LSM 是将一个大树拆分成N棵小树，先写到内存（无寻道问题，性能高），在内存中构建一颗有序小树（有序树），随着小树越来越大，内存的小树会flush到磁盘上。当读时，由于不知道数据在哪棵小树上，因此必须遍历（二分查找）所有的小树，但在每颗小树内部数据是有序的。\r\n\t\r\n* [《LSM树（Log-Structured Merge Tree）存储引擎》](https://blog.csdn.net/u014774781/article/details/52105708)\r\n\t* 极端的说，基于LSM树实现的HBase的写性能比MySQL高了一个数量级，读性能低了一个数量级。\r\n\t* 优化方式：Bloom filter 替代二分查找；compact 小数位大树，提高查询性能。\r\n\t* Hbase 中，内存中达到一定阈值后，整体flush到磁盘上、形成一个文件（B+数），HDFS不支持update操作，所以Hbase做整体flush而不是merge update。flush到磁盘上的小树，定期会合并成一个大树。\r\n\r\n## BitSet\r\n\r\n经常用于大规模数据的排重检查。\r\n\r\n* [《Java Bitset类》](http://www.runoob.com/java/java-bitset-class.html)\r\n* [《Java BitSet（位集）》](https://blog.csdn.net/caiandyong/article/details/51581160)\r\n\r\n# 常用算法\r\n\r\n* [《常见排序算法及对应的时间复杂度和空间复杂度》](https://blog.csdn.net/gane_cheng/article/details/52652705)\r\n\r\n## 排序、查找算法\r\n\r\n* [《常见排序算法及对应的时间复杂度和空间复杂度》](https://blog.csdn.net/gane_cheng/article/details/52652705)\r\n\r\n### 选择排序\r\n* [《Java中的经典算法之选择排序（SelectionSort）》](https://www.cnblogs.com/shen-hua/p/5424059.html)\r\n\t* 每一趟从待排序的记录中选出最小的元素，顺序放在已排好序的序列最后，直到全部记录排序完毕。\r\n\r\n### 冒泡排序\r\n* [《冒泡排序的2种写法》](https://blog.csdn.net/shuaizai88/article/details/73250615)\r\n\t* 相邻元素前后交换、把最大的排到最后。\r\n\t* 时间复杂度 O(n²) \r\n\r\n### 插入排序\r\n* [《排序算法总结之插入排序》](https://www.cnblogs.com/hapjin/p/5517667.html)\r\n\r\n### 快速排序\r\n* [《坐在马桶上看算法：快速排序》](http://developer.51cto.com/art/201403/430986.htm)\r\n\t* 一侧比另外一次都大或小。 \r\n### 归并排序\r\n* [《图解排序算法(四)之归并排序》](http://www.cnblogs.com/chengxiao/p/6194356.html)\r\n\t* 分而治之，分成小份排序，在合并(重建一个新空间进行复制)。 \r\n\r\n### 希尔排序\r\nTODO\r\n\r\n### 堆排序\r\n* [《图解排序算法(三)之堆排序》](https://www.cnblogs.com/chengxiao/p/6129630.html)\r\n\t* 排序过程就是构建最大堆的过程，最大堆：每个结点的值都大于或等于其左右孩子结点的值，堆顶元素是最大值。\r\n\r\n### 计数排序\r\n* [《计数排序和桶排序》](https://www.cnblogs.com/suvllian/p/5495780.html)\r\n\t* 和桶排序过程比较像，差别在于桶的数量。\r\n\r\n### 桶排序\r\n* [《【啊哈！算法】最快最简单的排序——桶排序》](http://blog.51cto.com/ahalei/1362789)\r\n* [《排序算法（三）：计数排序与桶排序》](https://blog.csdn.net/sunjinshengli/article/details/70738527)\r\n\t* 桶排序将[0,1)区间划分为n个相同的大小的子区间，这些子区间被称为桶。\r\n\t* 每个桶单独进行排序，然后再遍历每个桶。\r\n\r\n### 基数排序\r\n\r\n按照个位、十位、百位、...依次来排。\r\n\r\n* [《排序算法系列：基数排序》](https://blog.csdn.net/lemon_tree12138/article/details/51695211)\r\n* [《基数排序》](https://www.cnblogs.com/skywang12345/p/3603669.html)\r\n\r\n\r\n### 二分查找\r\n* [《二分查找(java实现)》](https://www.cnblogs.com/coderising/p/5708632.html)\r\n\t* 要求待查找的序列有序。\r\n\t* 时间复杂度 O(logN)。\r\n\r\n* [《java实现二分查找-两种方式》](https://blog.csdn.net/maoyuanming0806/article/details/78176957)\r\n\t* while + 递归。\r\n### Java 中的排序工具\r\n* [《Arrays.sort和Collections.sort实现原理解析》](https://blog.csdn.net/u011410529/article/details/56668545?locationnum=6\u0026fps=1)\r\n\t* Collections.sort算法调用的是合并排序。\r\n\t* Arrays.sort() 采用了2种排序算法 -- 基本类型数据使用快速排序法，对象数组使用归并排序。\r\n\r\n## 布隆过滤器\r\n\r\n常用于大数据的排重，比如email，url 等。\r\n核心原理：将每条数据通过计算产生一个指纹（一个字节或多个字节，但一定比原始数据要少很多），其中每一位都是通过随机计算获得，在将指纹映射到一个大的按位存储的空间中。注意：会有一定的错误率。\r\n优点：空间和时间效率都很高。\r\n缺点：随着存入的元素数量增加，误算率随之增加。\r\n\r\n* [《布隆过滤器 -- 空间效率很高的数据结构》](https://segmentfault.com/a/1190000002729689)\r\n* [《大量数据去重：Bitmap和布隆过滤器(Bloom Filter)》](https://blog.csdn.net/zdxiq000/article/details/57626464)\r\n* [《基于Redis的布隆过滤器的实现》](https://blog.csdn.net/qq_30242609/article/details/71024458)\r\n\t* 基于 Redis 的 Bitmap 数据结构。\r\n* [《网络爬虫：URL去重策略之布隆过滤器(BloomFilter)的使用》](https://blog.csdn.net/lemon_tree12138/article/details/47973715)\r\n\t* 使用Java中的 BitSet 类 和 加权和hash算法。\r\n\r\n## 字符串比较\r\n\r\n### KMP 算法\r\nKMP：Knuth-Morris-Pratt算法（简称KMP）\r\n核心原理是利用一个“部分匹配表”，跳过已经匹配过的元素。\r\n* [《字符串匹配的KMP算法》](http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html)\r\n\r\n## 深度优先、广度优先\r\n* [《广度优先搜索BFS和深度优先搜索DFS》](https://www.cnblogs.com/0kk470/p/7555033.html)\r\n\r\n## 贪心算法\r\n* [《算法：贪婪算法基础》](https://www.cnblogs.com/MrSaver/p/8641971.html)\r\n* [《常见算法及问题场景——贪心算法》](https://blog.csdn.net/a345017062/article/details/52443781)\r\n\r\n## 回溯算法\r\n* [《 五大常用算法之四：回溯法》](https://blog.csdn.net/qfikh/article/details/51960331)\r\n\r\n## 剪枝算法\r\n* [《α-β剪枝算法》](https://blog.csdn.net/luningcsdn/article/details/50930276)\r\n\r\n## 动态规划\r\n* [《详解动态规划——邹博讲动态规划》](https://www.cnblogs.com/little-YTMM/p/5372680.html)\r\n* [《动态规划算法的个人理解》](https://blog.csdn.net/yao_zi_jie/article/details/54580283)\r\n\r\n## 朴素贝叶斯\r\n\r\n* [《带你搞懂朴素贝叶斯分类算法》](https://blog.csdn.net/amds123/article/details/70173402)\r\n\t* P(B|A)=P(A|B)P(B)/P(A)\r\n\r\n* [《贝叶斯推断及其互联网应用1》](http://www.ruanyifeng.com/blog/2011/08/bayesian_inference_part_one.html)\r\n* [《贝叶斯推断及其互联网应用2》](http://www.ruanyifeng.com/blog/2011/08/bayesian_inference_part_two.html)\r\n\r\n\r\n## 推荐算法\r\n* [《推荐算法综述》](http://www.infoq.com/cn/articles/recommendation-algorithm-overview-part01)\r\n* [《TOP 10 开源的推荐系统简介》](https://www.oschina.net/news/51297/top-10-open-source-recommendation-systems)\r\n\r\n## 最小生成树算法\r\n* [《算法导论--最小生成树（Kruskal和Prim算法）》](https://blog.csdn.net/luoshixian099/article/details/51908175)\r\n\r\n## 最短路径算法\r\n\r\n* [《Dijkstra算法详解》](https://blog.csdn.net/qq_35644234/article/details/60870719)\r\n\r\n# 并发\r\n\r\n## Java 并发\r\n\r\n* [Java 并发知识合集](https://github.com/CL0610/Java-concurrency)\r\n* [JAVA并发知识图谱](https://github.com/CL0610/Java-concurrency/blob/master/Java并发知识图谱.png)\r\n\r\n## 多线程\r\n\r\n* [《40个Java多线程问题总结》](http://www.importnew.com/18459.html)\r\n\r\n## 线程安全\r\n\r\n* [《Java并发编程——线程安全及解决机制简介》](https://www.cnblogs.com/zhanht/p/5450325.html)\r\n\r\n## 一致性、事务\r\n\r\n### 事务 ACID 特性\r\n* [《数据库事务ACID特性》](https://blog.csdn.net/u012440687/article/details/52116108)\r\n\r\n### 事务的隔离级别\r\n\r\n* 未提交读：一个事务可以读取另一个未提交的数据，容易出现脏读的情况。\r\n* 读提交：一个事务等另外一个事务提交之后才可以读取数据，但会出现不可重复读的情况（多次读取的数据不一致），读取过程中出现UPDATE操作，会多。（大多数数据库默认级别是RC，比如SQL Server，Oracle），读取的时候不可以修改。\r\n* 可重复读： 同一个事务里确保每次读取的时候，获得的是同样的数据，但不保障原始数据被其他事务更新（幻读），Mysql InnoDB 就是这个级别。\r\n* 序列化：所有事物串行处理（牺牲了效率）\r\n\r\n* [《理解事务的4种隔离级别》](https://blog.csdn.net/qq_33290787/article/details/51924963)\r\n* [数据库事务的四大特性及事务隔离级别](https://www.cnblogs.com/z-sm/p/7245981.html)\r\n\r\n* [《MySQL的InnoDB的幻读问题 》](http://blog.sina.com.cn/s/blog_499740cb0100ugs7.html)\r\n\t* 幻读的例子非常清楚。\r\n\t* 通过 SELECT ... FOR UPDATE 解决。\r\n\t\r\n* [《一篇文章带你读懂MySQL和InnoDB》](http://database.51cto.com/art/201804/570101.htm)\r\n\t* 图解脏读、不可重复读、幻读问题。\r\n\r\n\r\n### MVCC\r\n\r\n\r\n* [《【mysql】关于innodb中MVCC的一些理解》](https://www.cnblogs.com/chenpingzhao/p/5065316.html)\r\n\t* innodb 中 MVCC 用在 Repeatable-Read 隔离级别。\r\n\t* MVCC 会产生幻读问题（更新时异常。）\r\n\r\n* [《轻松理解MYSQL MVCC 实现机制》](https://blog.csdn.net/whoamiyang/article/details/51901888)\r\n\r\n\t* 通过隐藏版本列来实现 MVCC 控制，一列记录创建时间、一列记录删除时间，这里的时间\r\n\t* 每次只操作比当前版本小（或等于）的 行。\r\n\t\r\n\r\n\r\n## 锁\r\n\r\n### Java中的锁和同步类\r\n\r\n* [《Java中的锁分类》](https://www.cnblogs.com/qifengshi/p/6831055.html)\r\n\t* 主要包括 synchronized、ReentrantLock、和 ReadWriteLock。 \r\n\r\n* [《Java并发之AQS详解》](https://www.cnblogs.com/waterystone/p/4920797.html)\r\n\r\n* [《Java中信号量 Semaphore》](http://cuisuqiang.iteye.com/blog/2020146)\r\n\t* 有数量控制\r\n\t* 申请用 acquire，申请不要则阻塞；释放用 release。\r\n\r\n* [《java开发中的Mutex vs Semaphore》](https://www.cnblogs.com/davidwang456/p/6094947.html)\r\n\t* 简单的说 就是Mutex是排它的，只有一个可以获取到资源， Semaphore也具有排它性，但可以定义多个可以获取的资源的对象。\t \r\n\r\n### 公平锁 \u0026 非公平锁\r\n\r\n公平锁的作用就是严格按照线程启动的顺序来执行的，不允许其他线程插队执行的；而非公平锁是允许插队的。\r\n\r\n* [《公平锁与非公平锁》](https://blog.csdn.net/EthanWhite/article/details/55508357)\r\n\t* 默认情况下 ReentrantLock 和 synchronized 都是非公平锁。ReentrantLock 可以设置成公平锁。\r\n\r\n### 悲观锁 \r\n\r\n悲观锁如果使用不当（锁的条数过多），会引起服务大面积等待。推荐优先使用乐观锁+重试。\r\n\r\n* [《【MySQL】悲观锁\u0026乐观锁》](https://www.cnblogs.com/zhiqian-ali/p/6200874.html)\r\n\t* 乐观锁的方式：版本号+重试方式\r\n\t* 悲观锁：通过 select ... for update 进行行锁(不可读、不可写，share 锁可读不可写)。\r\n\r\n* [《Mysql查询语句使用select.. for update导致的数据库死锁分析》](https://www.cnblogs.com/Lawson/p/5008741.html)\r\n\t* mysql的innodb存储引擎实务锁虽然是锁行，但它内部是锁索引的。\r\n\t* 锁相同数据的不同索引条件可能会引起死锁。\r\n\t\r\n* [《Mysql并发时经典常见的死锁原因及解决方法》](https://www.cnblogs.com/zejin2008/p/5262751.html)\r\n\r\n### 乐观锁 \u0026 CAS\r\n\r\n* [《乐观锁的一种实现方式——CAS》](http://www.importnew.com/20472.html)\r\n\t* 和MySQL乐观锁方式相似，只不过是通过和原值进行比较。\t \r\n\r\n### ABA 问题\r\n\r\n由于高并发，在CAS下，更新后可能此A非彼A。通过版本号可以解决，类似于上文Mysql 中提到的的乐观锁。\r\n\r\n* [《Java CAS 和ABA问题》](https://www.cnblogs.com/549294286/p/3766717.html)\r\n* [《Java 中 ABA问题及避免》](https://blog.csdn.net/li954644351/article/details/50511879)\r\n\t* AtomicStampedReference 和 AtomicStampedReference。 \r\n\r\n### CopyOnWrite容器\r\n\r\n可以对CopyOnWrite容器进行并发的读，而不需要加锁。CopyOnWrite并发容器用于读多写少的并发场景。比如白名单，黑名单，商品类目的访问和更新场景，不适合需要数据强一致性的场景。\r\n\r\n* [《JAVA中写时复制(Copy-On-Write)Map实现》](https://www.cnblogs.com/hapjin/p/4840107.html)\r\n\t* 实现读写分离，读取发生在原始数据上，写入发生在副本上。  \r\n\t* 不用加锁，通过最终一致实现一致性。\r\n\t\r\n* [《聊聊并发-Java中的Copy-On-Write容器》](https://blog.csdn.net/a494303877/article/details/53404623)\r\n\r\n### RingBuffer \r\n* [《线程安全的无锁RingBuffer的实现【一个读线程，一个写线程】》](http://www.cnblogs.com/l00l/p/4115001.html)\r\n\r\n### 可重入锁 \u0026 不可重入锁\r\n\r\n* [《可重入锁和不可重入锁》](https://www.cnblogs.com/dj3839/p/6580765.html)\r\n\t* 通过简单代码举例说明可重入锁和不可重入锁。\r\n\t* 可重入锁指同一个线程可以再次获得之前已经获得的锁。\r\n\t* 可重入锁可以用户避免死锁。\r\n\t* Java中的可重入锁：synchronized 和 java.util.concurrent.locks.ReentrantLock\r\n\r\n* [《ReenTrantLock可重入锁（和synchronized的区别）总结》](https://www.cnblogs.com/baizhanshi/p/7211802.html)\r\n\t* synchronized 使用方便，编译器来加锁，是非公平锁。\r\n\t* ReenTrantLock 使用灵活，锁的公平性可以定制。\r\n\t* 相同加锁场景下，推荐使用 synchronized。\r\n\r\n### 互斥锁 \u0026 共享锁\r\n\r\n互斥锁：同时只能有一个线程获得锁。比如，ReentrantLock 是互斥锁，ReadWriteLock 中的写锁是互斥锁。\r\n共享锁：可以有多个线程同时或的锁。比如，Semaphore、CountDownLatch 是共享锁，ReadWriteLock 中的读锁是共享锁。\r\n\r\n* [《ReadWriteLock场景应用》](https://www.cnblogs.com/liang1101/p/6475555.html)\r\n\r\n### 死锁\r\n* [《“死锁”四个必要条件的合理解释》](https://blog.csdn.net/yunfenglw/article/details/45950305)\r\n\t* 互斥、持有、不可剥夺、环形等待。\r\n* [Java如何查看死锁？](https://blog.csdn.net/u014039577/article/details/52351626)\r\n\t* JConsole 可以识别死锁。\r\n\t\r\n* [java多线程系列：死锁及检测](https://blog.csdn.net/bohu83/article/details/51135061)\r\n\t* jstack 可以显示死锁。\r\n\t\r\n# 操作系统\r\n\r\n## 计算机原理\r\n\r\n* [《操作系统基础知识——操作系统的原理，类型和结构》](https://segmentfault.com/a/1190000003692840)\r\n\r\n## CPU\r\n\r\n### 多级缓存\r\n典型的 CPU 有三级缓存，距离核心越近，速度越快，空间越小。L1 一般 32k，L2 一般 256k，L3 一般12M。内存速度需要200个 CPU 周期，CPU 缓存需要1个CPU周期。\r\n\r\n* [《从Java视角理解CPU缓存和伪共享》](https://blog.csdn.net/zero__007/article/details/54089730)\r\n\r\n## 进程\r\n\r\nTODO\r\n\r\n## 线程\r\n\r\n* [《线程的生命周期及状态转换详解》](https://blog.csdn.net/asdf_1024/article/details/78978437)\r\n\r\n## 协程\r\n\r\n* [《终结python协程----从yield到actor模型的实现》](https://www.thinksaas.cn/group/topic/839375/)\r\n\t* 线程的调度是由操作系统负责，协程调度是程序自行负责\r\n\t* 与线程相比，协程减少了无谓的操作系统切换.\r\n\t* 实际上当遇到IO操作时做切换才更有意义，（因为IO操作不用占用CPU），如果没遇到IO操作，按照时间片切换.\r\n\t\r\n## Linux\r\n\r\n* [《Linux 命令大全》](http://www.runoob.com/linux/linux-command-manual.html)\r\n\r\n# 设计模式\r\n\r\n## 设计模式的六大原则\r\n* [《设计模式的六大原则》](https://blog.csdn.net/q291611265/article/details/48465113)\r\n\t* 开闭原则：对扩展开放,对修改关闭，多使用抽象类和接口。\r\n\t* 里氏替换原则：基类可以被子类替换，使用抽象类继承,不使用具体类继承。\r\n\t* 依赖倒转原则：要依赖于抽象,不要依赖于具体，针对接口编程,不针对实现编程。\r\n\t* 接口隔离原则：使用多个隔离的接口,比使用单个接口好，建立最小的接口。\r\n\t* 迪米特法则：一个软件实体应当尽可能少地与其他实体发生相互作用，通过中间类建立联系。\r\n\t* 合成复用原则：尽量使用合成/聚合,而不是使用继承。\r\n\r\n## 23种常见设计模式\r\n* [《设计模式》](http://www.runoob.com/design-pattern/design-pattern-tutorial.html)\r\n* [《23种设计模式全解析》](https://www.cnblogs.com/susanws/p/5510229.html)\r\n\r\n## 应用场景\r\n* [《细数JDK里的设计模式》](http://blog.jobbole.com/62314/)\r\n\t* 结构型模式：\r\n\t\t* 适配器：用来把一个接口转化成另一个接口，如 java.util.Arrays#asList()。\r\n\t\t* 桥接模式：这个模式将抽象和抽象操作的实现进行了解耦，这样使得抽象和实现可以独立地变化，如JDBC；\r\n\t\t* 组合模式：使得客户端看来单个对象和对象的组合是同等的。换句话说，某个类型的方法同时也接受自身类型作为参数，如 Map.putAll，List.addAll、Set.addAll。\r\n\t\t* 装饰者模式：动态的给一个对象附加额外的功能，这也是子类的一种替代方式，如 java.util.Collections#checkedList|Map|Set|SortedSet|SortedMap。\r\n\t\t* 享元模式：使用缓存来加速大量小对象的访问时间，如 valueOf(int)。\r\n\t\t* 代理模式：代理模式是用一个简单的对象来代替一个复杂的或者创建耗时的对象，如 java.lang.reflect.Proxy\r\n\t\t\r\n\t* 创建模式:\r\n\t\t* 抽象工厂模式：抽象工厂模式提供了一个协议来生成一系列的相关或者独立的对象，而不用指定具体对象的类型，如 java.util.Calendar#getInstance()。\r\n\t\t* 建造模式(Builder)：定义了一个新的类来构建另一个类的实例，以简化复杂对象的创建，如：java.lang.StringBuilder#append()。\r\n\t\t* 工厂方法：就是 **一个返*** 回具体对象的方法，而不是多个，如 java.lang.Object#toString()、java.lang.Class#newInstance()。\r\n\t\t* 原型模式：使得类的实例能够生成自身的拷贝、如：java.lang.Object#clone()。\r\n\t\t* 单例模式：全局只有一个实例，如 java.lang.Runtime#getRuntime()。\r\n\t* 行为模式：\r\n\t\t* 责任链模式：通过把请求从一个对象传递到链条中下一个对象的方式，直到请求被处理完毕，以实现对象间的解耦。如 javax.servlet.Filter#doFilter()。\r\n\t\t* 命令模式：将操作封装到对象内，以便存储，传递和返回，如：java.lang.Runnable。\r\n\t\t* 解释器模式：定义了一个语言的语法，然后解析相应语法的语句，如，java.text.Format，java.text.Normalizer。\r\n\t\t* 迭代器模式：提供一个一致的方法来顺序访问集合中的对象，如 java.util.Iterator。\r\n\t\t* 中介者模式：通过使用一个中间对象来进行消息分发以及减少类之间的直接依赖，java.lang.reflect.Method#invoke()。\r\n\t\t* 空对象模式：如 java.util.Collections#emptyList()。\r\n\t\t* 观察者模式：它使得一个对象可以灵活的将消息发送给感兴趣的对象，如 java.util.EventListener。\r\n\t\t* 模板方法模式：让子类可以重写方法的一部分，而不是整个重写，如 java.util.Collections#sort()。\r\n\r\n* [《Spring-涉及到的设计模式汇总》](https://www.cnblogs.com/hwaggLee/p/4510687.html)\r\n* [《Mybatis使用的设计模式》](https://blog.csdn.net/u012387062/article/details/54719114)\r\n\r\n## 单例模式\r\n* [《单例模式的三种实现 以及各自的优缺点》](https://blog.csdn.net/YECrazy/article/details/79481964)\r\n* [《单例模式－－反射－－防止序列化破坏单例模式》](https://www.cnblogs.com/ttylinux/p/6498822.html)\r\n\t* 使用枚举类型。\r\n\r\n## 责任链模式\r\nTODO\r\n\r\n## MVC\r\n* [《MVC 模式》](http://www.runoob.com/design-pattern/mvc-pattern.html)\r\n\t* 模型(model)－视图(view)－控制器(controller) \r\n\r\n## IOC\r\n* [《理解 IOC》](https://www.zhihu.com/question/23277575)\r\n* [《IOC 的理解与解释》](https://www.cnblogs.com/NancyStartOnce/p/6813162.html)\r\n\t* 正向控制：传统通过new的方式。反向控制，通过容器注入对象。\r\n\t* 作用：用于模块解耦。\r\n\t* DI：Dependency Injection，即依赖注入，只关心资源使用，不关心资源来源。\r\n\r\n## AOP\r\n\r\n* [《轻松理解AOP(面向切面编程)》](https://my.oschina.net/yanquan345/blog/203415)\r\n* [《Spring AOP详解》](https://www.cnblogs.com/hongwz/p/5764917.html)\r\n* [《Spring AOP的实现原理》](http://www.importnew.com/24305.html)\r\n\t* Spring AOP使用的动态代理，主要有两种方式：JDK动态代理和CGLIB动态代理。\r\n* [《Spring AOP 实现原理与 CGLIB 应用》](https://www.ibm.com/developerworks/cn/java/j-lo-springaopcglib/)\r\n\t* Spring AOP 框架对 AOP 代理类的处理原则是：如果目标对象的实现类实现了接口，Spring AOP 将会采用 JDK 动态代理来生成 AOP 代理类；如果目标对象的实现类没有实现接口，Spring AOP 将会采用 CGLIB 来生成 AOP 代理类 \r\n\r\n\r\n## UML\r\n\r\n* [《UML教程》](https://www.w3cschool.cn/uml_tutorial/)\r\n\r\n## 微服务思想\r\n* [《微服务架构设计》](https://www.cnblogs.com/wintersun/p/6219259.html)\r\n* [《微服务架构技术栈选型手册》](http://www.infoq.com/cn/articles/micro-service-technology-stack)\r\n\r\n### 康威定律\r\n* [《微服务架构的理论基础 - 康威定律》](https://yq.aliyun.com/articles/8611)\r\n\t* 定律一：组织沟通方式会通过系统设计表达出来，就是说架构的布局和组织结构会有相似。\r\n\t* 定律二：时间再多一件事情也不可能做的完美，但总有时间做完一件事情。一口气吃不成胖子，先搞定能搞定的。\r\n\t* 定律三：线型系统和线型组织架构间有潜在的异质同态特性。种瓜得瓜，做独立自治的子系统减少沟通成本。\r\n\t* 定律四：大的系统组织总是比小系统更倾向于分解。合久必分，分而治之。\r\n\r\n* [《微服务架构核⼼20讲》](https://static.geekbang.org/PDF-%E4%BF%AE%E6%94%B9%E7%89%88-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4-%E5%9B%BE%E7%89%87-%E6%9D%A8%E6%B3%A2-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84.pdf)\r\n\r\n# 运维 \u0026 统计 \u0026 技术支持 \r\n\r\n## 常规监控\r\n\r\n* [《腾讯业务系统监控的修炼之路》](https://blog.csdn.net/enweitech/article/details/77849205)\r\n\t* 监控的方式：主动、被动、旁路(比如舆情监控)\r\n\t* 监控类型： 基础监控、服务端监控、客户端监控、\r\n\t监控、用户端监控\r\n\t* 监控的目标：全、块、准\r\n\t* 核心指标：请求量、成功率、耗时\r\n\r\n* [《开源还是商用？十大云运维监控工具横评》](https://www.oschina.net/news/67525/monitoring-tools)\r\n\t* Zabbix、Nagios、Ganglia、Zenoss、Open-falcon、监控宝、 360网站服务监控、阿里云监控、百度云观测、小蜜蜂网站监测等。\r\n\r\n* [《监控报警系统搭建及二次开发经验》](http://developer.51cto.com/art/201612/525373.htm)\r\n\r\n**命令行监控工具**\r\n\r\n* [《常用命令行监控工具》](https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/44-an-quan-yu-yun-wei/445-fu-wu-qi-zhuang-tai-jian-ce/4451-ming-ling-xing-gong-ju.html)\r\n\t* top、sar、tsar、nload\r\n\r\n* [《20个命令行工具监控 Linux 系统性能》](http://blog.jobbole.com/96846/)\r\n\r\n* [《JVM性能调优监控工具jps、jstack、jmap、jhat、jstat、hprof使用详解》](https://my.oschina.net/feichexia/blog/196575)\r\n\r\n## APM\r\n\r\nAPM —  Application Performance Management\r\n\r\n* [《Dapper，大规模分布式系统的跟踪系统》](http://bigbully.github.io/Dapper-translation/)\r\n\r\n* [CNCF OpenTracing](http://opentracing.io)，[中文版](https://github.com/opentracing-contrib/opentracing-specification-zh)\r\n\r\n* 主要开源软件，按字母排序\r\n  * [Apache SkyWalking](https://github.com/apache/incubator-skywalking)\r\n  * [CAT](https://github.com/dianping/cat)\r\n  * [CNCF jaeger](https://github.com/jaegertracing/jaeger)\r\n  * [Pinpoint](https://github.com/naver/pinpoint)\r\n  * [Zipkin](https://github.com/openzipkin/zipkin)\r\n\r\n* [《开源APM技术选型与实战》](http://www.infoq.com/cn/articles/apm-Pinpoint-practice)\r\n\t* 主要基于 Google的Dapper（大规模分布式系统的跟踪系统） 思想。\r\n\t\r\n\r\n\r\n## 统计分析\r\n\r\n* [《流量统计的基础：埋点》](https://zhuanlan.zhihu.com/p/25195217)\r\n\t* 常用指标：访问与访客、停留时长、跳出率、退出率、转化率、参与度\r\n\r\n* [《APP埋点常用的统计工具、埋点目标和埋点内容》](http://www.25xt.com/company/17066.html)\r\n\t* 第三方统计：友盟、百度移动、魔方、App Annie、talking data、神策数据等。\r\n\r\n* [《美团点评前端无痕埋点实践》](https://tech.meituan.com/mt-mobile-analytics-practice.html)\r\n\t* 所谓无痕、即通过可视化工具配置采集节点，在前端自动解析配置并上报埋点数据，而非硬编码。 \r\n\r\n\r\n## 持续集成(CI/CD)\r\n\r\n* [《持续集成是什么？》](http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html)\r\n* [《8个流行的持续集成工具》](https://www.testwo.com/article/1170)\r\n\r\n### Jenkins\r\n\r\n* [《使用Jenkins进行持续集成》](https://www.liaoxuefeng.com/article/001463233913442cdb2d1bd1b1b42e3b0b29eb1ba736c5e000)\r\n\r\n### 环境分离\r\n\r\n开发、测试、生成环境分离。\r\n\r\n* [《开发环境、生产环境、测试环境的基本理解和区》](https://my.oschina.net/sancuo/blog/214904)\r\n\r\n## 自动化运维\r\n\r\n### Ansible\r\n* [《Ansible中文权威指南》](http://www.ansible.com.cn/)\r\n* [《Ansible基础配置和企业级项目实用案例》](https://www.cnblogs.com/heiye123/articles/7855890.html)\r\n\r\n### puppet\r\n* [《自动化运维工具——puppet详解》](https://www.cnblogs.com/keerya/p/8040071.html)\r\n\r\n### chef\r\n* [《Chef 的安装与使用》](https://www.ibm.com/developerworks/cn/cloud/library/1407_caomd_chef/)\r\n\r\n## 测试\r\n\r\n### TDD 理论\r\n\r\n* [《深度解读 - TDD（测试驱动开发）》](https://www.jianshu.com/p/62f16cd4fef3)\r\n\t* 基于测试用例编码功能代码，XP（Extreme Programming）的核心实践.\r\n\t* 好处：一次关注一个点，降低思维负担；迎接需求变化或改善代码的设计；提前澄清需求；快速反馈； \r\n\r\n### 单元测试\r\n\r\n* [《Java单元测试之JUnit篇》](https://www.cnblogs.com/happyzm/p/6482886.html)\r\n* [《JUnit 4 与 TestNG 对比》](https://blog.csdn.net/hotdust/article/details/53406086)\r\n\t* TestNG 覆盖 JUnit 功能，适用于更复杂的场景。 \r\n* [《单元测试主要的测试功能点》](https://blog.csdn.net/wqetfg/article/details/50900512)\r\n\t* 模块接口测试、局部数据结构测试、路径测试 、错误处理测试、边界条件测试 。 \r\n\r\n### 压力测试\r\n\r\n* [《Apache ab 测试使用指南》](https://blog.csdn.net/blueheart20/article/details/52170790)\r\n* [《大型网站压力测试及优化方案》](https://www.cnblogs.com/binyue/p/6141088.html)\r\n* [《10大主流压力/负载/性能测试工具推荐》](http://news.chinabyte.com/466/14126966.shtml)\r\n* [《真实流量压测工具 tcpcopy应用浅析》](http://quentinxxz.iteye.com/blog/2249799)\r\n* [《nGrinder 简易使用教程》](https://www.cnblogs.com/jwentest/p/7136727.html)\r\n\r\n\r\n### 全链路压测\r\n* [《京东618：升级全链路压测方案，打造军演机器人ForceBot》](http://www.infoq.com/cn/articles/jd-618-upgrade-full-link-voltage-test-program-forcebot)\r\n* [《饿了么全链路压测的探索与实践》](https://zhuanlan.zhihu.com/p/30306892)\r\n* [《四大语言，八大框架｜滴滴全链路压测解决之道》](https://zhuanlan.zhihu.com/p/28355759)\r\n* [《全链路压测经验》](https://www.jianshu.com/p/27060fd61f72)\r\n\r\n\r\n### A/B 、灰度、蓝绿测试\r\n\r\n* [《技术干货 | AB 测试和灰度发布探索及实践》](https://testerhome.com/topics/11165)\r\n* [《nginx 根据IP 进行灰度发布》](http://blog.51cto.com/purplegrape/1403123)\r\n\r\n* [《蓝绿部署、A/B 测试以及灰度发布》](https://www.v2ex.com/t/344341)\r\n\r\n## 虚拟化\r\n\r\n* [《VPS的三种虚拟技术OpenVZ、Xen、KVM优缺点比较》](https://blog.csdn.net/enweitech/article/details/52910082)\r\n\r\n### KVM\r\n* [《KVM详解，太详细太深入了，经典》](http://blog.chinaunix.net/uid-20201831-id-5775661.html)\r\n* [《【图文】KVM 虚拟机安装详解》](https://www.coderxing.com/kvm-install.html)\r\n\r\n### Xen\r\n* [《Xen虚拟化基本原理详解》](https://www.cnblogs.com/sddai/p/5931201.html)\r\n\r\n### OpenVZ\r\n* [《开源Linux容器 OpenVZ 快速上手指南》](https://blog.csdn.net/longerzone/article/details/44829255)\r\n\r\n## 容器技术\r\n\r\n### Docker\r\n* [《几张图帮你理解 docker 基本原理及快速入门》](https://www.cnblogs.com/SzeCheng/p/6822905.html)\r\n* [《Docker 核心技术与实现原理》](https://draveness.me/docker)\r\n* [《Docker 教程》](http://www.runoob.com/docker/docker-tutorial.html)\r\n\r\n## 云技术\r\n\r\n### OpenStack\r\n* [《OpenStack构架知识梳理》](https://www.cnblogs.com/klb561/p/8660264.html)\r\n\r\n## DevOps\r\n* [《一分钟告诉你究竟DevOps是什么鬼？》](https://www.cnblogs.com/jetzhang/p/6068773.html)\r\n* [《DevOps详解》](http://www.infoq.com/cn/articles/detail-analysis-of-devops)\r\n\r\n## 文档管理\r\n\r\n* [Confluence-收费文档管理系统](http://www.confluence.cn/)\r\n* GitLab?\r\n* Wiki\r\n\r\n# 中间件\r\n\r\n## Web Server\r\n\r\n### Nginx\r\n* [《Ngnix的基本学习-多进程和Apache的比较》](https://blog.csdn.net/qq_25797077/article/details/52200722)\r\n\t* Nginx 通过异步非阻塞的事件处理机制实现高并发。Apache 每个请求独占一个线程，非常消耗系统资源。\r\n\t* 事件驱动适合于IO密集型服务(Nginx)，多进程或线程适合于CPU密集型服务(Apache)，所以Nginx适合做反向代理，而非web服务器使用。  \r\n\r\n* [《nginx与Apache的对比以及优缺点》](https://www.cnblogs.com/cunkouzh/p/5410154.html)\r\n\t* nginx只适合静态和反向代理，不适合处理动态请求。\r\n\r\n### OpenResty\r\n* [官方网站](http://openresty.org/cn/)\r\n* [《浅谈 OpenResty》](http://www.linkedkeeper.com/detail/blog.action?bid=1034)\r\n\t* 通过 Lua 模块可以在Nginx上进行开发。 \r\n\r\n### Apache Httpd\r\n* [官方网站](http://httpd.apache.org/)\r\n\r\n### Tomcat\r\n\r\n#### 架构原理\r\n* [《TOMCAT原理详解及请求过程》](https://www.cnblogs.com/hggen/p/6264475.html)\r\n* [《Tomcat服务器原理详解》](https://www.cnblogs.com/crazylqy/p/4706223.html)\r\n* [《Tomcat 系统架构与设计模式,第 1 部分: 工作原理》](https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/)\r\n\r\n* [《四张图带你了解Tomcat系统架构》](https://blog.csdn.net/xlgen157387/article/details/79006434)\r\n\r\n* [《JBoss vs. Tomcat: Choosing A Java Application Server》](https://www.futurehosting.com/blog/jboss-vs-tomcat-choosing-a-java-application-server/)\r\n\t* Tomcat 是轻量级的 Serverlet 容器，没有实现全部 JEE 特性（比如持久化和事务处理），但可以通过其他组件代替，比如Srping。\r\n\t* Jboss 实现全部了JEE特性，软件开源免费、文档收费。\r\n\r\n#### 调优方案\r\n\r\n* [《Tomcat 调优方案》](https://www.cnblogs.com/sunfenqing/p/7339058.html)\r\n\t* 启动NIO模式（或者APR）；调整线程池；禁用AJP连接器（Nginx+tomcat的架构，不需要AJP）； \r\n\r\n* [《tomcat http协议与ajp协议》](http://blog.chinaunix.net/uid-20662363-id-3012760.html)\r\n* [《AJP与HTTP比较和分析》](http://dmouse.iteye.com/blog/1354527)\r\n\t* AJP 协议（8009端口）用于降低和前端Server（如Apache，而且需要支持AJP协议）的连接数(前端)，通过长连接提高性能。\r\n\t* 并发高时，AJP协议优于HTTP协议。\r\n\r\n### Jetty\r\n* [《Jetty 的工作原理以及与 Tomcat 的比较》](https://www.ibm.com/developerworks/cn/java/j-lo-jetty/)\r\n* [《jetty和tomcat优势比较》](https://blog.csdn.net/doutao6677/article/details/51957288)\r\n\t* 架构比较:Jetty的架构比Tomcat的更为简单。\r\n\t* 性能比较：Jetty和Tomcat性能方面差异不大，Jetty默认采用NIO结束在处理I/O请求上更占优势，Tomcat默认采用BIO处理I/O请求，Tomcat适合处理少数非常繁忙的链接，处理静态资源时性能较差。\r\n\t* 其他方面：Jetty的应用更加快速，修改简单，对新的Servlet规范的支持较好;Tomcat 对JEE和Servlet 支持更加全面。 \r\n\r\n\r\n\r\n## 缓存\r\n\r\n* [《缓存失效策略（FIFO 、LRU、LFU三种算法的区别）》](https://blog.csdn.net/clementad/article/details/48229243)\r\n\r\n### 本地缓存\r\n\r\n* [《HashMap本地缓存》](https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/421-ying-yong-ceng-ben-di-huan-cun/4211.html)\r\n\r\n* [《EhCache本地缓存》](https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/421-ying-yong-ceng-ben-di-huan-cun/4212-ehcache.html)\r\n\t* 堆内、堆外、磁盘三级缓存。\r\n\t* 可按照缓存空间容量进行设置。\r\n\t* 按照时间、次数等过期策略。\r\n\r\n* [《Guava Cache》](https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/421-ying-yong-ceng-ben-di-huan-cun/4213-guava-cache.html)\r\n\t* 简单轻量、无堆外、磁盘缓存。\r\n\r\n\r\n* [《Nginx本地缓存》](https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/422-fu-wu-duan-ben-di-huan-cun/nginx-ben-di-huan-cun.html)\r\n\r\n* [《Pagespeed—懒人工具，服务器端加速》](https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/422-fu-wu-duan-ben-di-huan-cun/4222-pagespeed.html)\r\n\r\n## 客户端缓存\r\n\r\n* [《浏览器端缓存》](https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/423-ke-hu-duan-huan-cun.html)\r\n\t* 主要是利用 Cache-Control 参数。\r\n\r\n* [《H5 和移动端 WebView 缓存机制解析与实战》](https://mp.weixin.qq.com/s/qHm_dJBhVbv0pJs8Crp77w)\r\n\r\n## 服务端缓存\r\n\r\n### Web缓存\r\n\r\n* [nuster](https://github.com/jiangwenyuan/nuster) - nuster cache\r\n* [varnish](https://github.com/varnishcache/varnish-cache) - varnish cache\r\n* [squid](https://github.com/squid-cache/squid) - squid cache\r\n\r\n### Memcached\r\n* [《Memcached 教程》](http://www.runoob.com/Memcached/Memcached-tutorial.html)\r\n* [《深入理解Memcached原理》](https://blog.csdn.net/chenleixing/article/details/47035453)\r\n\t* 采用多路复用技术提高并发性。\r\n\t* slab分配算法： memcached给Slab分配内存空间，默认是1MB。分配给Slab之后 把slab的切分成大小相同的chunk，Chunk是用于缓存记录的内存空间，Chunk 的大小默认按照1.25倍的速度递增。好处是不会频繁申请内存，提高IO效率，坏处是会有一定的内存浪费。\r\n* [《Memcached软件工作原理》](https://www.jianshu.com/p/36e5cd400580)\r\n* [《Memcache技术分享：介绍、使用、存储、算法、优化、命中率》](http://zhihuzeye.com/archives/2361)\r\n\r\n* [《memcache 中 add 、 set 、replace 的区别》](https://blog.csdn.net/liu251890347/article/details/37690045)\r\n\t* 区别在于当key存在还是不存在时，返回值是true和false的。\r\n\r\n* [**《memcached全面剖析》**](https://pan.baidu.com/s/1qX00Lti?errno=0\u0026errmsg=Auth%20Login%20Sucess\u0026\u0026bduss=\u0026ssnerror=0\u0026traceid=)\r\n\r\n### Redis\r\n\r\n* [《Redis 教程》](http://www.runoob.com/redis/redis-tutorial.html)\r\n* [《redis底层原理》](https://blog.csdn.net/wcf373722432/article/details/78678504)\r\n\t* 使用 ziplist 存储链表，ziplist是一种压缩链表，它的好处是更能节省内存空间，因为它所存储的内容都是在连续的内存区域当中的。\r\n\t* 使用 skiplist(跳跃表)来存储有序集合对象、查找上先从高Level查起、时间复杂度和红黑树相当，实现容易，无锁、并发性好。\r\n* [《Redis持久化方式》](http://doc.redisfans.com/topic/persistence.html)\r\n\t* RDB方式：定期备份快照，常用于灾难恢复。优点：通过fork出的进程进行备份，不影响主进程、RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。缺点：会丢数据。\r\n\t* AOF方式：保存操作日志方式。优点：恢复时数据丢失少，缺点：文件大，回复慢。\r\n\t* 也可以两者结合使用。\r\n\r\n* [《分布式缓存--序列3--原子操作与CAS乐观锁》](https://blog.csdn.net/chunlongyu/article/details/53346436)\r\n\r\n#### 架构\r\n* [《Redis单线程架构》](https://blog.csdn.net/sunhuiliang85/article/details/73656830)\r\n\r\n#### 回收策略\r\n* [《redis的回收策略》](https://blog.csdn.net/qq_29108585/article/details/63251491)\r\n\r\n### Tair\r\n\r\n* [官方网站](https://github.com/alibaba/tair)\r\n* [《Tair和Redis的对比》](http://blog.csdn.net/farphone/article/details/53522383)\r\n* 特点：可以配置备份节点数目，通过异步同步到备份节点\r\n* 一致性Hash算法。\r\n* 架构：和Hadoop 的设计思想类似，有Configserver，DataServer，Configserver 通过心跳来检测，Configserver也有主备关系。\r\n\r\n\r\n几种存储引擎:\r\n* MDB，完全内存性，可以用来存储Session等数据。\r\n* Rdb（类似于Redis），轻量化，去除了aof之类的操作，支持Restfull操作\r\n* LDB（LevelDB存储引擎），持久化存储，LDB 作为rdb的持久化，google实现，比较高效，理论基础是LSM(Log-Structured-Merge Tree)算法，现在内存中修改数据，达到一定量时（和内存汇总的旧数据一同写入磁盘）再写入磁盘，存储更加高效，县比喻Hash算法。\r\n* Tair采用共享内存来存储数据，如果服务挂掉（非服务器），重启服务之后，数据亦然还在。\r\n\r\n## 消息队列\r\n\r\n* [《消息队列-推/拉模式学习 \u0026 ActiveMQ及JMS学习》](https://www.cnblogs.com/charlesblc/p/6045238.html)\r\n\t* RabbitMQ 消费者默认是推模式（也支持拉模式）。\r\n\t* Kafka 默认是拉模式。\r\n\t* Push方式：优点是可以尽可能快地将消息发送给消费者，缺点是如果消费者处理能力跟不上，消费者的缓冲区可能会溢出。\r\n\t* Pull方式：优点是消费端可以按处理能力进行拉去，缺点是会增加消息延迟。\r\n\r\n* [《Kafka、RabbitMQ、RocketMQ等消息中间件的对比 —— 消息发送性能和区别》](https://blog.csdn.net/yunfeng482/article/details/72856762)\r\n\r\n### 消息总线\r\n\r\n消息总线相当于在消息队列之上做了一层封装，统一入口，统一管控、简化接入成本。\r\n\r\n* [《消息总线VS消息队列》](https://blog.csdn.net/yanghua_kobe/article/details/43877281)\r\n\r\n### 消息的顺序\r\n* [《如何保证消费者接收消息的顺序》](https://www.cnblogs.com/cjsblog/p/8267892.html)\r\n\r\n### RabbitMQ\r\n\r\n支持事务，推拉模式都是支持、适合需要可靠性消息传输的场景。\r\n\r\n* [《RabbitMQ的应用场景以及基本原理介绍》](https://blog.csdn.net/whoamiyang/article/details/54954780)\r\n* [《消息队列之 RabbitMQ》](https://www.jianshu.com/p/79ca08116d57) \r\n* [《RabbitMQ之消息确认机制（事务+Confirm）》](https://blog.csdn.net/u013256816/article/details/55515234)\r\n\r\n### RocketMQ\r\nJava实现，推拉模式都是支持，吞吐量逊于Kafka。可以保证消息顺序。\r\n* [《RocketMQ 实战之快速入门》](https://www.jianshu.com/p/824066d70da8)\r\n* [《RocketMQ 源码解析》](http://www.iocoder.cn/categories/RocketMQ/?vip\u0026architect-awesome)\r\n\r\n### ActiveMQ\r\n纯Java实现，兼容JMS，可以内嵌于Java应用中。\r\n* [《ActiveMQ消息队列介绍》](https://www.cnblogs.com/wintersun/p/3962302.html)\r\n\r\n### Kafka\r\n高吞吐量、采用拉模式。适合高IO场景，比如日志同步。\r\n\r\n* [官方网站](http://kafka.apache.org/)\r\n* [《各消息队列对比，Kafka深度解析，众人推荐，精彩好文！》](https://blog.csdn.net/allthesametome/article/details/47362451)\r\n* [《Kafka分区机制介绍与示例》](http://lxw1234.com/archives/2015/10/538.htm)\r\n\r\n### Redis 消息推送\r\n\r\n生产者、消费者模式完全是客户端行为，list 和 拉模式实现，阻塞等待采用 blpop 指令。\r\n\r\n* [《Redis学习笔记之十：Redis用作消息队列》](https://blog.csdn.net/qq_34212276/article/details/78455004)\r\n\r\n### ZeroMQ\r\n TODO\r\n\r\n\r\n## 定时调度\r\n\r\n### 单机定时调度\r\n\r\n* [《linux定时任务cron配置》](https://www.cnblogs.com/shuaiqing/p/7742382.html)\r\n\r\n* [《Linux cron运行原理》](https://my.oschina.net/daquan/blog/483305)\r\n\t* fork 进程 + sleep 轮询\r\n\r\n* [《Quartz使用总结》](https://www.cnblogs.com/drift-ice/p/3817269.html)\r\n* [《Quartz源码解析 ---- 触发器按时启动原理》](https://blog.csdn.net/wenniuwuren/article/details/42082981/)\r\n* [《quartz原理揭秘和源码解读》](https://www.jianshu.com/p/bab8e4e32952)\r\n\t* 定时调度在 QuartzSchedulerThread 代码中，while()无限循环，每次循环取出时间将到的trigger，触发对应的job，直到调度器线程被关闭。\r\n\r\n\r\n### 分布式定时调度\r\n\r\n* [《这些优秀的国产分布式任务调度系统，你用过几个？》](https://blog.csdn.net/qq_16216221/article/details/70314337)\r\n\t* opencron、LTS、XXL-JOB、Elastic-Job、Uncode-Schedule、Antares\r\n\r\n* [《Quartz任务调度的基本实现原理》](https://www.cnblogs.com/zhenyuyaodidiao/p/4755649.html)\r\n\t* Quartz集群中，独立的Quartz节点并不与另一其的节点或是管理节点通信，而是通过相同的数据库表来感知到另一Quartz应用的 \r\n* [《Elastic-Job-Lite 源码解析》](http://www.iocoder.cn/categories/Elastic-Job-Lite/?vip\u0026architect-awesome)\r\n* [《Elastic-Job-Cloud 源码解析》](http://www.iocoder.cn/categories/Elastic-Job-Cloud/?vip\u0026architect-awesome)\r\n\r\n\r\n## RPC\r\n\r\n* [《从零开始实现RPC框架 - RPC原理及实现》](https://blog.csdn.net/top_code/article/details/54615853)\r\n\t* 核心角色：Server: 暴露服务的服务提供方、Client: 调用远程服务的服务消费方、Registry: 服务注册与发现的注册中心。\r\n\r\n* [《分布式RPC框架性能大比拼 dubbo、motan、rpcx、gRPC、thrift的性能比较》](https://blog.csdn.net/testcs_dn/article/details/78050590)\r\n\r\n### Dubbo\r\n* [官方网站](http://dubbo.apache.org/)\r\n* [dubbo实现原理简单介绍](https://www.cnblogs.com/steven520213/p/7606598.html)\r\n\r\n** SPI **\r\nTODO\r\n\r\n### Thrift\r\n* [官方网站](http://thrift.apache.org/)\r\n* [《Thrift RPC详解》](https://blog.csdn.net/kesonyk/article/details/50924489)\r\n\t* 支持多语言，通过中间语言定义接口。\r\n\r\n### gRPC\r\n\r\n服务端可以认证加密，在外网环境下，可以保证数据安全。\r\n\r\n* [官方网站](https://grpc.io/)\r\n* [《你应该知道的RPC原理》](https://www.cnblogs.com/LBSer/p/4853234.html)\r\n\r\n\r\n## 数据库中间件\r\n\r\n### Sharding Jdbc\r\n\r\n* [官网](http://shardingjdbc.io/)\r\n\r\n## 日志系统\r\n\r\n### 日志搜集\r\n\r\n* [《从零开始搭建一个ELKB日志收集系统》](http://cjting.me/misc/build-log-system-with-elkb/)\r\n* [《用ELK搭建简单的日志收集分析系统》](https://blog.csdn.net/lzw_2006/article/details/51280058)\r\n* [《日志收集系统-探究》](https://www.cnblogs.com/beginmind/p/6058194.html)\r\n\r\n## 配置中心\r\n\r\n* [Apollo - 携程开源的配置中心应用](https://github.com/ctripcorp/apollo)\r\n\t* Spring Boot 和 Spring Cloud\r\n\t* 支持推、拉模式更新配置\r\n\t* 支持多种语言 \r\n\r\n* [《基于zookeeper实现统一配置管理》](https://blog.csdn.net/u011320740/article/details/78742625)\r\n\r\n* [《 Spring Cloud Config 分布式配置中心使用教程》](https://www.cnblogs.com/shamo89/p/8016908.html)\r\n\r\nservlet 3.0 异步特性可用于配置中心的客户端\r\n* [《servlet3.0 新特性——异步处理》](https://www.cnblogs.com/dogdogwang/p/7151866.html)\r\n\r\n## API 网关\r\n\r\n主要职责：请求转发、安全认证、协议转换、容灾。\r\n\r\n* [《API网关那些儿》](http://yunlzheng.github.io/2017/03/14/the-things-about-api-gateway/)\r\n* [《谈API网关的背景、架构以及落地方案》](http://www.infoq.com/cn/news/2016/07/API-background-architecture-floo)\r\n\r\n* [《使用Zuul构建API Gateway》](https://blog.csdn.net/zhanglh046/article/details/78651993)\r\n* [《Spring Cloud Gateway 源码解析》](http://www.iocoder.cn/categories/Spring-Cloud-Gateway/?vip\u0026architect-awesome)\r\n* [《HTTP API网关选择之一Kong介绍》](https://mp.weixin.qq.com/s/LIq2CiXJQmmjBC0yvYLY5A)\r\n\r\n# 网络\r\n\r\n\r\n## 协议\r\n\r\n### OSI 七层协议\r\n\r\n* [《OSI七层协议模型、TCP/IP四层模型学习笔记》](https://www.cnblogs.com/Robin-YB/p/6668762.html)\r\n\r\n### TCP/IP\r\n* [《深入浅出 TCP/IP 协议》](https://www.cnblogs.com/onepixel/p/7092302.html)\r\n* [《TCP协议中的三次握手和四次挥手》](https://blog.csdn.net/whuslei/article/details/6667471/)\r\n\r\n### HTTP\r\n* [《http协议详解(超详细)》](https://www.cnblogs.com/wangning528/p/6388464.html)\r\n\r\n### HTTP2.0\r\n* [《HTTP 2.0 原理详细分析》](https://blog.csdn.net/zhuyiquan/article/details/69257126)\r\n* [《HTTP2.0的基本单位为二进制帧》](https://blog.csdn.net/u012657197/article/details/77877840)\r\n\t* 利用二进制帧负责传输。\r\n\t* 多路复用。\r\n\r\n### HTTPS\r\n* [《https原理通俗了解》](https://www.cnblogs.com/zhangshitong/p/6478721.html)\r\n\t* 使用非对称加密协商加密算法\r\n\t* 使用对称加密方式传输数据\r\n\t* 使用第三方机构签发的证书，来加密公钥，用于公钥的安全传输、防止被中间人串改。\r\n\r\n* [《八大免费SSL证书-给你的网站免费添加Https安全加密》](https://blog.csdn.net/enweitech/article/details/53213862)\r\n\r\n## 网络模型\r\n\r\n* [《web优化必须了解的原理之I/o的五种模型和web的三种工作模式》](http://blog.51cto.com/litaotao/1289790)\r\n\t* 五种I/O模型：阻塞I/O，非阻塞I/O，I/O复用、事件(信号)驱动I/O、异步I/O，前四种I/O属于同步操作，I/O的第一阶段不同、第二阶段相同，最后的一种则属于异步操作。\r\n\t* 三种 Web Server 工作方式：Prefork(多进程)、Worker方式(线程方式)、Event方式。\r\n\r\n* [《select、poll、epoll之间的区别总结》](http://www.cnblogs.com/Anker/p/3265058.html)\r\n\t* select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的。\r\n\t* select 有打开文件描述符数量限制，默认1024（2048 for x64），100万并发，就要用1000个进程、切换开销大；poll采用链表结构，没有数量限制。\r\n\t* select，poll “醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，通过回调机制节省大量CPU时间；select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，而epoll只要一次拷贝。\r\n\t* poll会随着并发增加，性能逐渐下降，epoll采用红黑树结构，性能稳定，不会随着连接数增加而降低。\r\n\t\r\n* [《select，poll，epoll比较  》](http://xingyunbaijunwei.blog.163.com/blog/static/76538067201241685556302/)\r\n\t* 在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。\r\n\r\n* [《深入理解Java NIO》](https://www.cnblogs.com/geason/p/5774096.html)\r\n\t* NIO 是一种同步非阻塞的 IO 模型。同步是指线程不断轮询 IO 事件是否就绪，非阻塞是指线程在等待 IO 的时候，可以同时做其他任务\r\n\r\n* [《BIO与NIO、AIO的区别》](https://blog.csdn.net/skiof007/article/details/52873421)\r\n\r\n* [《两种高效的服务器设计模型：Reactor和Proactor模型》](https://blog.csdn.net/u013074465/article/details/46276967)\r\n\r\n### Epoll\r\n\r\n* [《epoll使用详解（精髓）》](https://www.cnblogs.com/fnlingnzb-learner/p/5835573.html)\r\n\r\n### Java NIO\r\n* [《深入理解Java NIO》](https://www.cnblogs.com/geason/p/5774096.html)\r\n* [《Java NIO编写Socket服务器的一个例子》](https://blog.csdn.net/xidianliuy/article/details/51612676)\r\n\r\n### kqueue\r\n* [《kqueue用法简介》](http://www.cnblogs.com/luminocean/p/5631336.html)\r\n\r\n## 连接和短连接\r\n\r\n* [《TCP/IP系列——长连接与短连接的区别》](https://www.cnblogs.com/pangguoping/p/5571422.html)\r\n\r\n## 框架\r\n\r\n* [《Netty原理剖析》](https://blog.csdn.net/excellentyuxiao/article/details/53390408)\r\n\t* Reactor 模式介绍。\r\n\t* Netty 是 Reactor 模式的一种实现。\r\n\r\n## 零拷贝（Zero-copy）\r\n* [《对于 Netty ByteBuf 的零拷贝(Zero Copy) 的理解》](https://www.cnblogs.com/xys1228/p/6088805.html)\r\n\t* 多个物理分离的buffer，通过逻辑上合并成为一个，从而避免了数据在内存之间的拷贝。\r\n\r\n## 序列化(二进制协议)\r\n\r\n### Hessian\r\n* [《Hessian原理分析》](https://www.cnblogs.com/happyday56/p/4268249.html)\r\nBinary-RPC;不仅仅是序列化\r\n\r\n### Protobuf\r\n* [《Protobuf协议的Java应用例子》](https://blog.csdn.net/antgan/article/details/52103966)\r\nGoolge出品、占用空间和效率完胜其他序列化类库，如Hessian；需要编写  .proto 文件。\r\n* [《Protocol Buffers序列化协议及应用》](https://worktile.com/tech/share/prototol-buffers)\r\n  \t* 关于协议的解释；缺点：可读性差;\r\n\r\n* [《简单的使用 protobuf 和 protostuff》](https://blog.csdn.net/eric520zenobia/article/details/53766571)\r\n\t* protostuff 的好处是不用写 .proto 文件，Java 对象直接就可以序列化。\r\n\r\n# 数据库\r\n## 基础理论\r\n### 数据库设计的三大范式\r\n* [《数据库的三大范式以及五大约束》](https://www.cnblogs.com/waj6511988/p/7027127.html)\r\n\t* 第一范式：数据表中的每一列（每个字段）必须是不可拆分的最小单元，也就是确保每一列的原子性；\r\n\t* 第二范式（2NF）：满足1NF后，要求表中的所有列，都必须依赖于主键，而不能有任何一列与主键没有关系，也就是说一个表只描述一件事情；\r\n\t* 第三范式：必须先满足第二范式（2NF），要求：表中的每一列只与主键直接相关而不是间接相关，（表中的每一列只能依赖于主键）；\r\n\r\n## MySQL\r\n\r\n### 原理\r\n* [《MySQL的InnoDB索引原理详解》](http://www.admin10000.com/document/5372.html)\r\n\r\n* [《MySQL存储引擎－－MyISAM与InnoDB区别》](https://blog.csdn.net/xifeijian/article/details/20316775)\r\n\t* 两种类型最主要的差别就是Innodb 支持事务处理与外键和行级锁\r\n\r\n* [《myisam和innodb索引实现的不同》](https://www.2cto.com/database/201211/172380.html)\r\n\r\n### InnoDB\r\n\r\n* [《一篇文章带你读懂Mysql和InnoDB》](https://my.oschina.net/kailuncen/blog/1504217)\r\n\r\n### 优化\r\n\r\n* [《MySQL36条军规》](http://vdisk.weibo.com/s/muWOT)\r\n\r\n* [《MYSQL性能优化的最佳20+条经验》](https://www.cnblogs.com/zhouyusheng/p/8038224.html)\r\n* [《SQL优化之道》](https://blog.csdn.net/when_less_is_more/article/details/70187459)\r\n* [《mysql数据库死锁的产生原因及解决办法》](https://www.cnblogs.com/sivkun/p/7518540.html)\r\n* [《导致索引失效的可能情况》](https://blog.csdn.net/monkey_d_feilong/article/details/52291556)\r\n* [《 MYSQL分页limit速度太慢优化方法》](https://blog.csdn.net/zy_281870667/article/details/51604540)\r\n\t* 原则上就是缩小扫描范围。\r\n\r\n\r\n### 索引\r\n\r\n#### 聚集索引, 非聚集索引\r\n\r\n* [《MySQL 聚集索引/非聚集索引简述》](https://blog.csdn.net/no_endless/article/details/77073549)\r\n* [《MyISAM和InnoDB的索引实现》](https://www.cnblogs.com/zlcxbb/p/5757245.html)\r\n\r\nMyISAM 是非聚集，InnoDB 是聚集\r\n\r\n#### 复合索引\r\n\r\n* [《复合索引的优点和注意事项》](https://www.cnblogs.com/summer0space/p/7247778.html)\r\n\r\n#### 自适应哈希索引(AHI)\r\n\r\n* [《InnoDB存储引擎——自适应哈希索引》](https://blog.csdn.net/Linux_ever/article/details/62043708)\r\n\r\n\r\n### explain\r\n* [《MySQL 性能优化神器 Explain 使用分析》](https://segmentfault.com/a/1190000008131735)\r\n\r\n## NoSQL\r\n\r\n### MongoDB\r\n\r\n* [MongoDB 教程](http://www.runoob.com/mongodb/mongodb-tutorial.html)\r\n* [《Mongodb相对于关系型数据库的优缺点》](http://mxdxm.iteye.com/blog/2093603)\r\n\t* 优点：弱一致性（最终一致），更能保证用户的访问速度；内置GridFS，支持大容量的存储；Schema-less 数据库，不用预先定义结构；内置Sharding；相比于其他NoSQL，第三方支持丰富；性能优越；\r\n\t* 缺点：mongodb不支持事务操作；mongodb占用空间过大；MongoDB没有如MySQL那样成熟的维护工具，这对于开发和IT运营都是个值得注意的地方；\r\n\r\n### Hbase\r\n\r\n* [《简明 HBase 入门教程（开篇）》](http://www.thebigdata.cn/HBase/35831.html)\r\n* [《深入学习HBase架构原理》](https://www.cnblogs.com/qiaoyihang/p/6246424.html)\r\n* [《传统的行存储和（HBase）列存储的区别》](https://blog.csdn.net/youzhouliu/article/details/67632882)\r\n\r\n\r\n* [《Hbase与传统数据库的区别》](https://blog.csdn.net/lifuxiangcaohui/article/details/39891099)\r\n\t* 空数据不存储，节省空间，且适用于并发。\r\n\r\n* [《HBase Rowkey设计》](https://blog.csdn.net/u014091123/article/details/73163088)\r\n\t* rowkey 按照字典顺序排列，便于批量扫描。\r\n\t* 通过散列可以避免热点。\r\n\r\n# 搜索引擎\r\n\r\n## 搜索引擎原理\r\n\r\n* [《倒排索引--搜索引擎入门》](https://www.jianshu.com/p/0193dc44135b)\r\n\r\n## Lucene\r\n* [《Lucene入门简介》](https://www.cnblogs.com/rodge-run/p/6551152.html)\r\n\r\n## Elasticsearch\r\n\r\n* [《Elasticsearch学习，请先看这一篇！》](https://blog.csdn.net/laoyang360/article/details/52244917)\r\n* [《Elasticsearch索引原理》](https://blog.csdn.net/cyony/article/details/65437708)\r\n\r\n## Solr\r\n* [《 Apache Solr入门教程》](https://blog.csdn.net/u011936655/article/details/51960005)\r\n* [《elasticsearch与solr比较》](https://blog.csdn.net/convict_eva/article/details/53537837)\r\n\r\n## sphinx \r\n* [《Sphinx 的介绍和原理探索》](http://blog.jobbole.com/101672/)\r\n\r\n# 性能\r\n\r\n## 性能优化方法论\r\n\r\n* [《15天的性能优化工作，5方面的调优经验》](https://blog.csdn.net/huangwenyi1010/article/details/72673447?ref=myread)\r\n\t* 代码层面、业务层面、数据库层面、服务器层面、前端优化。\r\n\r\n* [《系统性能优化的几个方面》](https://blog.csdn.net/tenglizhe/article/details/44563135)\r\n\r\n## 容量评估\r\n* [《联网性能与容量评估的方法论和典型案例》](https://blog.csdn.net/u012528360/article/details/70054156)\r\n* [《互联网架构，如何进行容量设计？》](https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==\u0026mid=2651959542\u0026idx=1\u0026sn=2494bbea9a855e0e1c3ccd6d2562a600\u0026scene=21#wechat_redirect)\r\n\t* 评估总访问量、评估平均访问量QPS、评估高峰QPS、评估系统、单机极限QPS\r\n\r\n## CDN 网络\r\n\r\n* [《CDN加速原理》](https://www.cnblogs.com/wxiaona/p/5867685.html)\r\n* [《国内有哪些比较好的 CDN？》](https://www.zhihu.com/question/20536932)\r\n\r\n## 连接池\r\n\r\n* [《主流Java数据库连接池比较与开发配置实战》](https://blog.csdn.net/fysuccess/article/details/66972554)\r\n\r\n## 性能调优\r\n\r\n* [《九大Java性能调试工具，必备至少一款》](https://blog.csdn.net/yethyeth/article/details/73266455)\r\n\r\n\r\n# 大数据\r\n\r\n## 流式计算\r\n\r\n### Storm\r\n* [官方网站](http://storm.apache.org/)\r\n* [《最详细的Storm入门教程》](https://blog.csdn.net/uisoul/article/details/77989927)\r\n\r\n### Flink\r\n* [《Flink之一 Flink基本原理介绍》](https://blog.csdn.net/lisi1129/article/details/54844919)\r\n\r\n### Kafka Stream\r\n* [《Kafka Stream调研：一种轻量级流计算模式》](https://yq.aliyun.com/articles/58382)\r\n\r\n### 应用场景\r\n\r\n例如：\r\n\r\n* 广告相关实时统计；\r\n* 推荐系统用户画像标签实时更新；\r\n* 线上服务健康状况实时监测；\r\n* 实时榜单；\r\n* 实时数据统计。\r\n\r\n## Hadoop\r\n\r\n* [《用通俗易懂的话说下hadoop是什么,能做什么》](https://blog.csdn.net/houbin0912/article/details/72967178)\r\n* [《史上最详细的Hadoop环境搭建》](http://gitbook.cn/books/5954c9600326c7705af8a92a/index.html)\r\n\r\n### HDFS\r\n* [《【Hadoop学习】HDFS基本原理》](https://segmentfault.com/a/1190000011575458)\r\n\r\n### MapReduce\r\n* [《用通俗易懂的大白话讲解Map/Reduce原理》](https://blog.csdn.net/oppo62258801/article/details/72884633)\r\n* [《 简单的map-reduce的java例子》](https://blog.csdn.net/foye12/article/details/78358292)\r\n\r\n### Yarn\r\n* [《初步掌握Yarn的架构及原理》](http://www.cnblogs.com/codeOfLife/p/5492740.html)\r\n\r\n## Spark\r\n* [《Spark(一): 基本架构及原理》](http://www.cnblogs.com/tgzhu/p/5818374.html)\r\n\r\n\r\n# 安全\r\n\r\n## web 安全\r\n\r\n### XSS\r\n* [《xss攻击原理与解决方法》](https://blog.csdn.net/qq_21956483/article/details/54377947)\r\n### CSRF\r\n* [《CSRF原理及防范》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/641-web-an-quan-fang-fan/6412-csrf.html)\r\n\r\n### SQL 注入\r\n\r\n* [《SQL注入》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/641-web-an-quan-fang-fan/6413-sql-zhu-ru.html)\r\n\r\n### Hash Dos\r\n\r\n\r\n* [《邪恶的JAVA HASH DOS攻击》](http://www.freebuf.com/articles/web/14199.html)\r\n\t* 利用JsonObjet 上传大Json，JsonObject 底层使用HashMap；不同的数据产生相同的hash值，使得构建Hash速度变慢，耗尽CPU。\r\n* [《一种高级的DoS攻击-Hash碰撞攻击》](https://yq.aliyun.com/articles/92194?t=t1)\r\n* [《关于Hash Collision DoS漏洞：解析与解决方案》](http://www.iteye.com/news/23939/)\r\n\r\n### 脚本注入\r\n\r\n* [《上传文件漏洞原理及防范》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/641-web-an-quan-fang-fan/6414-shang-chuan-wen-jian-guo-lv.html)\r\n\r\n### 漏洞扫描工具\r\n* [《DVWA》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/6421-dvwa.html)\r\n* [W3af](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/w3af.html)\r\n* [OpenVAS详解](https://blog.csdn.net/xygg0801/article/details/53610640)\r\n\r\n### 验证码\r\n\r\n* [《验证码原理分析及实现》](https://blog.csdn.net/niaonao/article/details/51112686)\r\n\r\n* [《详解滑动验证码的实现原理》](https://my.oschina.net/jiangbianwanghai/blog/1031031)\r\n\t* 滑动验证码是根据人在滑动滑块的响应时间，拖拽速度，时间，位置，轨迹，重试次数等来评估风险。\r\n\r\n* [《淘宝滑动验证码研究》](https://www.cnblogs.com/xcj26/p/5242758.html)\r\n\r\n## DDoS 防范\r\n* [《学习手册：DDoS的攻击方式及防御手段》](http://netsecurity.51cto.com/art/201601/503799.htm)\r\n* [《免费DDoS攻击测试工具大合集》](http://netsecurity.51cto.com/art/201406/442756.htm)\r\n\r\n## 用户隐私信息保护\r\n\r\n1. 用户密码非明文保存，加动态salt。\r\n2. 身份证号，手机号如果要显示，用 “\\*” 替代部分字符。\r\n3. 联系方式在的显示与否由用户自己控制。\r\n4. TODO\r\n\r\n* [《个人隐私包括哪些》](https://zhidao.baidu.com/question/1988017976673661587.html)\r\n* [《在互联网上，隐私的范围包括哪些？》](https://www.zhihu.com/question/20137108)\r\n\r\n* [《用户密码保存》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6425-jia-mi-chang-jing-ff1a-yong-hu-mi-ma-bao-cun.html)\r\n\r\n## 序列化漏洞\r\n* [《Lib之过？Java反序列化漏洞通用利用分析》](https://blog.chaitin.cn/2015-11-11_java_unserialize_rce/)\r\n\r\n## 加密解密\r\n\r\n### 对称加密\r\n\r\n* [《常见对称加密算法》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6421-chang-jian-dui-cheng-jia-mi-suan-fa.html)\r\n\t* DES、3DES、Blowfish、AES\r\n\t* DES 采用 56位秘钥，Blowfish 采用1到448位变长秘钥，AES 128，192和256位长度的秘钥。\r\n\t* DES 秘钥太短（只有56位）算法目前已经被 AES 取代，并且 AES 有硬件加速，性能很好。\r\n\t\r\n### 哈希算法\r\n* [《常用的哈希算法》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6422-chang-jian-ha-xi-suan-fa-and-hmac.html)\r\n\t* MD5 和 SHA-1 已经不再安全，已被弃用。\r\n\t* 目前 SHA-256 是比较安全的。\r\n\t\r\n* [《基于Hash摘要签名的公网URL签名验证设计方案》](https://blog.csdn.net/zhangruhong168/article/details/78033202)\r\n\r\n### 非对称加密\r\n* [《常见非对称加密算法》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6424-chang-yong-fei-dui-cheng-jia-mi-suan-fa.html)\r\n\t* RSA、DSA、ECDSA(螺旋曲线加密算法)\r\n\t* 和 RSA 不同的是 DSA 仅能用于数字签名，不能进行数据加密解密，其安全性和RSA相当，但其性能要比RSA快。\r\n\t* 256位的ECC秘钥的安全性等同于3072位的RSA秘钥。\r\n\r\n\t\t[《区块链的加密技术》](http://baijiahao.baidu.com/s?id=1578348858092033763\u0026wfr=spider\u0026for=pc)\t\r\n\r\n\r\n## 服务器安全\r\n* [《Linux强化论：15步打造一个安全的Linux服务器》](http://www.freebuf.com/articles/system/121540.html)\r\n\r\n## 数据安全\r\n\r\n### 数据备份\r\n\r\nTODO\r\n\r\n## 网络隔离\r\n\r\n### 内外网分离\r\n\r\nTODO\r\n\r\n### 登录跳板机\r\n在内外环境中通过跳板机登录到线上主机。\r\n* [《搭建简易堡垒机》](http://blog.51cto.com/zero01/2062618)\r\n\r\n## 授权、认证\r\n### RBAC \r\n* [《基于组织角色的权限设计》](https://www.cnblogs.com/zq8024/p/5003050.html)\r\n* [《权限系统与RBAC模型概述》](https://www.cnblogs.com/shijiaqi1066/p/3793894.html)\r\n* [《Spring整合Shiro做权限控制模块详细案例分析》](https://blog.csdn.net/he90227/article/details/38663553)\r\n\r\n### OAuth2.0\r\n* [《理解OAuth 2.0》](http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html)\r\n* [《一张图搞定OAuth2.0》](https://www.cnblogs.com/flashsun/p/7424071.html)\r\n\r\n### 双因素认证（2FA）\r\n\r\n2FA - Two-factor authentication，用于加强登录验证\r\n\r\n常用做法是 登录密码 + 手机验证码（或者令牌Key，类似于与网银的 USB key）\r\n\r\n* 【《双因素认证（2FA）教程》】(http://www.ruanyifeng.com/blog/2017/11/2fa-tutorial.html)\r\n\r\n### 单点登录(SSO)\r\n\r\n* [《单点登录原理与简单实现》](https://www.cnblogs.com/ywlaker/p/6113927.html)\r\n\r\n* [CAS单点登录框架](https://github.com/apereo/cas)\r\n\r\n# 常用开源框架\r\n\r\n## 开源协议\r\n\r\n* [《开源协议的选择》](https://coderxing.gitbooks.io/architecture-evolution/chapter1/di-yi-zhang-ff1a-zhun-bei-qi-cheng/12-guan-yu-kai-yuan/123-kai-yuan-xie-yi-de-xuan-ze.html)\r\n\r\n* [如何选择一个开源软件协议](http://choosealicense.online/)\r\n\r\n## 日志框架\r\n\r\n### Log4j、Log4j2\r\n* [《log4j 详细讲解》](https://blog.csdn.net/u012422446/article/details/51199724)\r\n* [《log4j2 实际使用详解》](https://blog.csdn.net/vbirdbest/article/details/71751835)\r\n* [《Log4j1,Logback以及Log4j2性能测试对比》](https://my.oschina.net/OutOfMemory/blog/789267)\r\n\t* Log4J 异步日志性能优异。 \r\n\r\n### Logback\r\n* [《最全LogBack 详解、含java案例和配置说明》](https://blog.csdn.net/rulon147/article/details/52620541)\r\n\r\n## ORM\r\n\r\n* [《ORM框架使用优缺点》](https://blog.csdn.net/sinat_34093604/article/details/53082000)\r\n\t* 主要目的是为了提高开发效率。 \r\n\r\n**MyBatis：**\r\n\r\n* [《mybatis缓存机制详解》](https://www.cnblogs.com/winclpt/articles/7511672.html)\r\n\t* 一级缓存是SqlSession级别的缓存，缓存的数据只在SqlSession内有效\r\n\t* 二级缓存是mapper级别的缓存，同一个namespace公用这一个缓存，所以对SqlSession是共享的；使用 LRU 机制清理缓存，通过 cacheEnabled 参数开启。  \r\n\r\n* [《MyBatis学习之代码生成器Generator》](https://blog.csdn.net/baidu_32877851/article/details/53959268)\r\n\r\n## 网络框架\r\n\r\nTODO\r\n\r\n## Web 框架\r\n\r\n### Spring 家族\r\n**Spring**\r\n* [Spring 简明教程](https://www.w3cschool.cn/wkspring/)\r\n\r\n**Spring Boot**\r\n* [官方网站](http://projects.spring.io/spring-boot/)\r\n* [《Spring Boot基础教程》](http://blog.didispace.com/Spring-Boot%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/)\r\n\r\n**Spring Cloud**\r\n\r\n* [Spring Boot 中文索引站](http://springboot.fun/)\r\n* [Spring Cloud 中文文档](https://springcloud.cc/)\r\n* [《Spring Cloud基础教程》](http://blog.didispace.com/Spring-Cloud%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/)\r\n\r\n## 工具框架\r\n\r\n* [《Apache Commons 工具类介绍及简单使用》](https://www.cnblogs.com/crazylqy/p/4872236.html)\r\n* [《Google guava 中文教程》](http://ifeve.com/google-guava/)\r\n\r\n\r\n# 分布式设计\r\n\r\n## 扩展性设计\r\n\r\n* [《架构师不可不知的十大可扩展架构》](https://blog.csdn.net/hemin1003/article/details/53633926)\r\n\t* 总结下来，通用的套路就是分布、缓存及异步处理。 \r\n\r\n* [《可扩展性设计之数据切分》](https://yq.aliyun.com/articles/38119)\r\n\t* 水平切分+垂直切分\r\n\t* 利用中间件进行分片如，MySQL Proxy。\r\n\t* 利用分片策略进行切分，如按照ID取模。 \r\n* [《说说如何实现可扩展性的大型网站架构》](https://blog.csdn.net/deniro_li/article/details/78458306)\r\n\t* 分布式服务+消息队列。\r\n\r\n* [《大型网站技术架构（七）--网站的可扩展性架构》](https://blog.csdn.net/chaofanwei/article/details/29191073)\r\n\r\n## 稳定性 \u0026 高可用\r\n\r\n* [《系统设计：关于高可用系统的一些技术方案》](https://blog.csdn.net/hustspy1990/article/details/78008324)\r\n\t* 可扩展：水平扩展、垂直扩展。 通过冗余部署，避免单点故障。\r\n\t* 隔离：避免单一业务占用全部资源。避免业务之间的相互影响 2. 机房隔离避免单点故障。\r\n\t* 解耦：降低维护成本，降低耦合风险。减少依赖，减少相互间的影响。\r\n\t* 限流：滑动窗口计数法、漏桶算法、令牌桶算法等算法。遇到突发流量时，保证系统稳定。\r\n\t* 降级：紧急情况下释放非核心功能的资源。牺牲非核心业务，保证核心业务的高可用。\r\n\t* 熔断：异常情况超出阈值进入熔断状态，快速失败。减少不稳定的外部依赖对核心服务的影响。\r\n\t* 自动化测试：通过完善的测试，减少发布引起的故障。\r\n\t* 灰度发布：灰度发布是速度与安全性作为妥协，能够有效减少发布故障。\r\n\r\n\r\n* [《关于高可用的系统》](https://coolshell.cn/articles/17459.html)\r\n\t* 设计原则：数据不丢(持久化)；服务高可用(服务副本)；绝对的100%高可用很难，目标是做到尽可能多的9，如99.999%（全年累计只有5分钟）。\t \r\n\r\n### 硬件负载均衡\r\n\r\n* [《转！！负载均衡器技术Nginx和F5的优缺点对比》](https://www.cnblogs.com/wuyun-blog/p/6186198.html)\r\n\t* 主要是和F5对比。\r\n\r\n* [《软/硬件负载均衡产品 你知多少？》](https://www.cnblogs.com/lcword/p/5773296.html)\r\n\r\n### 软件负载均衡\r\n\r\n* [《几种负载均衡算法》](https://www.cnblogs.com/tianzhiliang/articles/2317808.html)\r\n\t轮寻、权重、负载、最少连接、QoS\r\n* [《DNS负载均衡》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/611-dns-fang-shi.html)\r\n\t* 配置简单，更新速度慢。 \r\n* [《Nginx负载均衡》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/613-nginx-fu-zai-jun-heng.html)\r\n\t* 简单轻量、学习成本低；主要适用于web应用。\r\n\r\n*  [《借助LVS+Keepalived实现负载均衡 》](https://www.cnblogs.com/edisonchou/p/4281978.html)\r\n\t* 配置比较负载、只支持到4层，性能较高。\r\n\r\n* [《HAProxy用法详解 全网最详细中文文档》](http://www.ttlsa.com/linux/haproxy-study-tutorial/)\r\n\t* 支持到七层（比如HTTP）、功能比较全面，性能也不错。\r\n\r\n* [《Haproxy+Keepalived+MySQL实现读均衡负载》](http://blog.itpub.net/25704976/viewspace-1319781/)\r\n\t* 主要是用户读请求的负载均衡。\r\n\r\n* [《rabbitmq+haproxy+keepalived实现高可用集群搭建》](https://www.cnblogs.com/lylife/p/5584019.html)\r\n\r\n### 限流\r\n\r\n* [《谈谈高并发系统的限流》](https://www.cnblogs.com/haoxinyue/p/6792309.html)\r\n\t* 计数器：通过滑动窗口计数器，控制单位时间内的请求次数，简单粗暴。\r\n\t* 漏桶算法：固定容量的漏桶，漏桶满了就丢弃请求，比较常用。\r\n\t* 令牌桶算法：固定容量的令牌桶，按照一定速率添加令牌，处理请求前需要拿到令牌，拿不到令牌则丢弃请求，或进入丢队列，可以通过控制添加令牌的速率，来控制整体速度。Guava 中的 RateLimiter 是令牌桶的实现。\r\n\t* Nginx 限流：通过 `limit_req` 等模块限制并发连接数。\r\n\r\n### 应用层容灾\r\n\r\n* [《防雪崩利器：熔断器 Hystrix 的原理与使用》](https://segmentfault.com/a/1190000005988895)\r\n\t* 雪崩效应原因：硬件故障、硬件故障、程序Bug、重试加大流量、用户大量请求。 \r\n\t* 雪崩的对策：限流、改进缓存模式(缓存预加载、同步调用改异步)、自动扩容、降级。\r\n\t* Hystrix设计原则：\r\n\t\t* 资源隔离：Hystrix通过将每个依赖服务分配独立的线程池进行资源隔离, 从而避免服务雪崩。\r\n\t\t* 熔断开关：服务的健康状况 = 请求失败数 / 请求总数，通过阈值设定和滑动窗口控制开关。\r\n\t\t* 命令模式：通过继承 HystrixCommand 来包装服务调用逻辑。 \r\n\r\n* [《缓存穿透，缓存击穿，缓存雪崩解决方案分析》](https://blog.csdn.net/zeb_perfect/article/details/54135506)\r\n* [《缓存击穿、失效以及热点key问题》](https://blog.csdn.net/zeb_perfect/article/details/54135506) \r\n\t* 主要策略：失效瞬间：单机使用锁；使用分布式锁；不过期；\r\n\t* 热点数据：热点数据单独存储；使用本地缓存；分成多个子key；\r\n\r\n### 跨机房容灾\r\n\r\n* [《“异地多活”多机房部署经验谈》](http://dc.idcquan.com/ywgl/71559.shtml)\r\n\t* 通过自研中间件进行数据同步。 \r\n\r\n* [《异地多活（异地双活）实践经验》](https://blog.csdn.net/jeffreynicole/article/details/48135093)\r\n\t* 注意延迟问题，多次跨机房调用会将延时放大数倍。\r\n\t* 建房间专线很大概率会出现问题，做好运维和程序层面的容错。\r\n\t* 不能依赖于程序端数据双写，要有自动同步方案。 \r\n\t* 数据永不在高延迟和较差网络质量下，考虑同步质量问题。\r\n\t* 核心业务和次要业务分而治之，甚至只考虑核心业务。\r\n\t* 异地多活监控部署、测试也要跟上。\r\n\t* 业务允许的情况下考虑用户分区，尤其是游戏、邮箱业务。\r\n\t* 控制跨机房消息体大小，越小越好。\r\n\t* 考虑使用docker容器虚拟化技术，提高动态调度能力。\r\n\r\n* [容灾技术及建设经验介绍](https://blog.csdn.net/yoara/article/details/38013751)\r\n\r\n\r\n### 容灾演练流程\r\n\r\n* [《依赖治理、灰度发布、故障演练，阿里电商故障演练系统的设计与实战经验》](https://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==\u0026mid=2650996320\u0026idx=1\u0026sn=0ed3be190bbee4a9277886ef88cbb2e5)\r\n\t* 常见故障画像\r\n\t* 案例：预案有效性、预案有效性、故障复现、架构容灾测试、参数调优、参数调优、故障突袭、联合演练。\r\n\r\n### 平滑启动\r\n\r\n* 平滑重启应用思路\r\n1.端流量（如vip层）、2. flush 数据(如果有)、3, 重启应用\r\n\r\n* [《JVM安全退出（如何优雅的关闭java服务）》](https://blog.csdn.net/u011001084/article/details/73480432)\r\n推荐推出方式：System.exit，Kill SIGTERM；不推荐 kill-9；用 Runtime.addShutdownHook 注册钩子。\r\n* [《常见Java应用如何优雅关闭》](http://ju.outofmemory.cn/entry/337235)\r\nJava、Srping、Dubbo 优雅关闭方式。\r\n\r\n## 数据库扩展\r\n\r\n### 读写分离模式\r\n\r\n* [《Mysql主从方案的实现》](https://www.cnblogs.com/houdj/p/6563771.html)\r\n* [《搭建MySQL主从复制经典架构》](https://www.cnblogs.com/edisonchou/p/4133148.html)\r\n* [《Haproxy+多台MySQL从服务器(Slave) 实现负载均衡》](https://blog.csdn.net/nimasike/article/details/48048341)\r\n\r\n* [《DRBD+Heartbeat+Mysql高可用读写分离架构》](https://www.cnblogs.com/zhangsubai/p/6801764.html)\r\n\t* DRDB 进行磁盘复制，避免单点问题。\r\n\r\n* [《MySQL Cluster 方式》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/62-ke-kuo-zhan-de-shu-ju-ku-jia-gou/621-gao-ke-yong-mysql-de-ji-zhong-fang-an/6214-mysql-cluster-fang-an.html)\r\n\r\n### 分片模式\r\n* [《分库分表需要考虑的问题及方案》](https://www.jianshu.com/p/32b3e91aa22c)\r\n\t* 中间件： 轻量级：sharding-jdbc、TSharding；重量级：Atlas、MyCAT、Vitess等。\r\n\t* 问题：事务、Join、迁移、扩容、ID、分页等。\r\n\t* 事务补偿：对数据进行对帐检查;基于日志进行比对;定期同标准数据来源进行同步等。\r\n\t* 分库策略：数值范围；取模；日期等。\r\n\t* 分库数量：通常 MySQL 单库 5千万条、Oracle 单库一亿条需要分库。 \r\n\r\n* [《MySql分表和表分区详解》](https://www.2cto.com/database/201503/380348.html)\r\n\t* 分区：是MySQL内部机制，对客户端透明，数据存储在不同文件中，表面上看是同一个表。\r\n\t* 分表：物理上创建不同的表、客户端需要管理分表路由。\r\n\r\n## 服务治理\r\n###  服务注册与发现\r\n\r\n* [《永不失联！如何实现微服务架构中的服务发现？》](https://blog.csdn.net/jiaolongdy/article/details/51188798)\r\n  * 客户端服务发现模式：客户端直接查询注册表，同时自己负责负载均衡。Eureka 采用这种方式。\r\n  * 服务器端服务发现模式：客户端通过负载均衡查询服务实例。\r\n* [《SpringCloud服务注册中心比较:Consul vs Zookeeper vs Etcd vs Eureka》](https://blog.csdn.net/u010963948/article/details/71730165)\r\n  * CAP支持：Consul（CA）、zookeeper（cp）、etcd（cp） 、euerka（ap）\r\n  * 作者认为目前 Consul 对 Spring cloud 的支持比较好。\r\n\r\n* [《基于Zookeeper的服务注册与发现》](http://mobile.51cto.com/news-502394.htm)\r\n\t* 优点：API简单、Pinterest，Airbnb 在用、多语言、通过watcher机制来实现配置PUSH，能快速响应配置变化。 \r\n\r\n### 服务路由控制\r\n* [《分布式服务框架学习笔记4 服务路由》](https://blog.csdn.net/xundh/article/details/59492750)\r\n\t* 原则：透明化路由\r\n\t* 负载均衡策略：随机、轮询、服务调用延迟、一致性哈希、粘滞连接\r\n\t* 本地路由有限策略：injvm(优先调用jvm内部的服务)，innative(优先使用相同物理机的服务),原则上找距离最近的服务。\r\n\t* 配置方式：统一注册表；本地配置；动态下发。\r\n\r\n## 分布式一致\r\n\r\n### CAP 与 BASE 理论\r\n\r\n* [《从分布式一致性谈到CAP理论、BASE理论》](http://www.cnblogs.com/szlbm/p/5588543.html)\r\n\t* 一致性分类：强一致(立即一致)；弱一致(可在单位时间内实现一致，比如秒级)；最终一致(弱一致的一种，一定时间内最终一致)\r\n\t* CAP：一致性、可用性、分区容错性(网络故障引起)\r\n\t* BASE：Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）\r\n\t* BASE理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。\r\n\r\n### 分布式锁\r\n\r\n* [《分布式锁的几种实现方式》](http://www.hollischuang.com/archives/1716)\r\n\t* 基于数据库的分布式锁：优点：操作简单、容易理解。缺点：存在单点问题、数据库性能够开销较大、不可重入；\r\n\t* 基于缓存的分布式锁：优点：非阻塞、性能好。缺点：操作不好容易造成锁无法释放的情况。\r\n\t* Zookeeper 分布式锁：通过有序临时节点实现锁机制，自己对应的节点需要最小，则被认为是获得了锁。优点：集群可以透明解决单点问题，避免锁不被释放问题，同时锁可以重入。缺点：性能不如缓存方式，吞吐量会随着zk集群规模变大而下降。\r\n* [《基于Zookeeper的分布式锁》](https://www.tuicool.com/articles/VZJr6fY)\r\n\t* 清楚的原理描述 + Java 代码示例。 \r\n\r\n* [《jedisLock—redis分布式锁实现》](https://www.cnblogs.com/0201zcr/p/5942748.html)\r\n\t* 基于 setnx(set if ont exists)，有则返回false，否则返回true。并支持过期时间。\r\n\r\n* [《Memcached 和 Redis 分布式锁方案》](https://blog.csdn.net/albertfly/article/details/77412333)\r\n\t* 利用 memcached 的 add（有别于set）操作，当key存在时，返回false。\r\n\r\n### 分布式一致性算法\r\n\r\n#### PAXOS\r\n* [《分布式系列文章——Paxos算法原理与推导》](https://www.cnblogs.com/linbingdong/p/6253479.html)\r\n* [《Paxos--\u003eFast Paxos--\u003eZookeeper分析》](https://blog.csdn.net/u010039929/article/details/70171672)\r\n* [《【分布式】Zookeeper与Paxos》](https://www.cnblogs.com/leesf456/p/6012777.html)\r\n\r\n#### Zab\r\n* [《Zab：Zookeeper 中的分布式一致性协议介绍》](https://www.jianshu.com/p/fb527a64deee)\r\n\r\n#### Raft\r\n* [《Raft 为什么是更易理解的分布式一致性算法》](http://www.cnblogs.com/mindwind/p/5231986.html)\r\n\t* 三种角色：Leader（领袖）、Follower（群众）、Candidate（候选人）\r\n\t* 通过随机等待的方式发出投票，得票多的获胜。\r\n\r\n#### Gossip\r\n* [《Gossip算法》](http://blog.51cto.com/tianya23/530743)\r\n\r\n#### 两阶段提交、多阶段提交\r\n\r\n* [《关于分布式事务、两阶段提交协议、三阶提交协议》](http://blog.jobbole.com/95632/)\r\n\r\n### 幂等\r\n\r\n* [《分布式系统---幂等性设计》](https://www.cnblogs.com/wxgblogs/p/6639272.html)\r\n\t* 幂等特性的作用：该资源具备幂等性，请求方无需担心重复调用会产生错误。\r\n\t* 常见保证幂等的手段：MVCC（类似于乐观锁）、去重表(唯一索引)、悲观锁、一次性token、序列号方式。 \r\n\r\n### 分布式一致方案\r\n* [《分布式系统事务一致性解决方案》](http://www.infoq.com/cn/articles/solution-of-distributed-system-transaction-consistency)\r\n* [《保证分布式系统数据一致性的6种方案》](https://weibo.com/ttarticle/p/show?id=2309403965965003062676)\r\n\r\n### 分布式 Leader 节点选举\r\n* [《利用zookeeper实现分布式leader节点选举》](https://blog.csdn.net/johnson_moon/article/details/78809995)\r\n\r\n### TCC(Try/Confirm/Cancel) 柔性事务\r\n* [《传统事务与柔性事务》](https://www.jianshu.com/p/ab1a1c6b08a1)\r\n\t* 基于BASE理论：基本可用、柔性状态、最终一致。\r\n\t* 解决方案：记录日志+补偿（正向补充或者回滚）、消息重试(要求程序要幂等)；“无锁设计”、采用乐观锁机制。\r\n\r\n## 分布式文件系统\r\n\r\n* [说说分布式文件存储系统-基本架构](https://zhuanlan.zhihu.com/p/27666295) ？\r\n* [《各种分布式文件系统的比较》](https://blog.csdn.net/gatieme/article/details/44982961) ？\r\n  * HDFS：大批量数据读写，用于高吞吐量的场景，不适合小文件。\r\n  * FastDFS：轻量级、适合小文件。\r\n\r\n## 唯一ID 生成\r\n\r\n### 全局唯一ID\r\n* [《高并发分布式系统中生成全局唯一Id汇总》](https://www.cnblogs.com/baiwa/p/5318432.html)\r\n\t* Twitter 方案（Snowflake 算法）：41位时间戳+10位机器标识（比如IP，服务器名称等）+12位序列号(本地计数器)\r\n\t* Flicker 方案：MySQL自增ID + \"REPLACE INTO XXX:SELECT LAST_INSERT_ID();\" \r\n\t* UUID：缺点，无序，字符串过长，占用空间，影响检索性能。\r\n\t* MongoDB 方案：利用 ObjectId。缺点：不能自增。\r\n\r\n* [《TDDL 在分布式下的SEQUENCE原理》](https://blog.csdn.net/hdu09075340/article/details/79103851)\r\n\t* 在数据库中创建 sequence 表，用于记录，当前已被占用的id最大值。\r\n\t* 每台客户端主机取一个id区间（比如 1000~2000）缓存在本地，并更新 sequence 表中的id最大值记录。\r\n\t* 客户端主机之间取不同的id区间，用完再取，使用乐观锁机制控制并发。\r\n\r\n## 一致性Hash算法\r\n\r\n* [《一致性哈希算法》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/631-yi-zhi-xing-ha-xi.html)\r\n\r\n# 设计思想 \u0026 开发模式\r\n\r\n## DDD(Domain-driven Design - 领域驱动设计)\r\n\r\n* [《浅谈我对DDD领域驱动设计的理解》](https://www.cnblogs.com/netfocus/p/5548025.html)\r\n  * 概念：DDD 主要对传统软件开发流程(分析-设计-编码)中各阶段的割裂问题而提出，避免由于一开始分析不明或在软件开发过程中的信息流转不一致而造成软件无法交付（和需求方设想不一致）的问题。DDD 强调一切以领域（Domain）为中心，强调领域专家（Domain Expert）的作用，强调先定义好领域模型之后在进行开发，并且领域模型可以指导开发（所谓的驱动）。\r\n  * 过程：理解领域、拆分领域、细化领域，模型的准确性取决于模型的理解深度。\r\n  * 设计：DDD 中提出了建模工具，比如聚合、实体、值对象、工厂、仓储、领域服务、领域事件来帮助领域建模。\r\n  \r\n* [《领域驱动设计的基础知识总结》](https://www.cnblogs.com/butterfly100/p/7827870.html)\r\n  * 领域（Doamin）本质上就是问题域，比如一个电商系统，一个论坛系统等。\r\n  * 界限上下文（Bounded Context）：阐述子域之间的关系，可以简单理解成一个子系统或组件模块。\r\n  * 领域模型（Domain Model）：DDD的核心是建立（用通用描述语言、工具—领域通用语言）正确的领域模型；反应业务需求的本质，包括实体和过程；其贯穿软件分析、设计、开发 的整个过程；常用表达领域模型的方式：图、代码或文字；\r\n  * 领域通用语言：领域专家、开发设计人员都能立即的语言或工具。\r\n  * 经典分层架构：用户界面/展示层、应用层、领域层、基础设施层，是四层架构模式。\r\n  * 使用的模式：\r\n    * 关联尽量少，尽量单项，尽量降低整体复杂度。\r\n    * 实体（Entity）：领域中的唯一标示，一个实体的属性尽量少，少则清晰。\r\n    * 值对象（Value Object）：没有唯一标识，且属性值不可变，小二简单的对象，比如Date。\r\n    * 领域服务（Domain Service）： 协调多个领域对象，只有方法没有状态(不存数据)；可以分为应用层服务，领域层服务、基础层服务。\r\n    * 聚合及聚合根（Aggregate，Aggregate Root）：聚合定义了一组具有内聚关系的相关对象的集合；聚合根是对聚合引用的唯一元素；当修改一个聚合时，必须在事务级别；大部分领域模型中，有70%的聚合通常只有一个实体，30%只有2~3个实体；如果一个聚合只有一个实体，那么这个实体就是聚合根；如果有多个实体，那么我们可以思考聚合内哪个对象有独立存在的意义并且可以和外部直接进行交互；\r\n    * 工厂（Factory）：类似于设计模式中的工厂模式。\r\n    * 仓储（Repository）：持久化到DB，管理对象，且只对聚合设计仓储。\r\n\r\n* [《领域驱动设计(DDD)实现之路》](http://www.cnblogs.com/Leo_wl/p/3866629.html)\r\n\t* 聚合：比如一辆汽车（Car）包含了引擎（Engine）、车轮（Wheel）和油箱（Tank）等组件，缺一不可。\r\n\r\n* [《领域驱动设计系列（2）浅析VO、DTO、DO、PO的概念、区别和用处》](http://www.hollischuang.com/archives/553)\r\n\r\n\r\n### 命令查询职责分离(CQRS)\r\n\r\nCQRS — Command Query Responsibility Seperation\r\n\r\n* [《领域驱动设计系列 (六)：CQRS》](https://www.cnblogs.com/cnblogsfans/p/4551990.html)\r\n\t* 核心思想：读写分离（查询和更新在不同的方法中），不同的流程只是不同的设计方式，CQ代码分离，分布式环境中会有明显体现（有冗余数据的情况下），目的是为了高性能。\r\n\r\n* [《DDD CQRS架构和传统架构的优缺点比较》](http://www.techweb.com.cn/network/system/2017-07-07/2553563.shtml)\r\n\t* 最终一致的设计理念；依赖于高可用消息中间件。\r\n\t\r\n* [《CQRS架构简介》](http://www.cnblogs.com/netfocus/p/4055346.html)\r\n\t* 一个实现 CQRS 的抽象案例。\r\n\r\n* [《深度长文：我对CQRS/EventSourcing架构的思考》](http://www.uml.org.cn/zjjs/201609221.asp)\r\n\t* CQRS 模式分析 + 12306 抢票案例\r\n\r\n### 贫血，充血模型\r\n\r\n* [《贫血，充血模型的解释以及一些经验》](https://kb.cnblogs.com/page/520743/)\r\n\t* 失血模型：老子和儿子分别定义，相互不知道，二者实体定义中完全没有业务逻辑，通过外部Service进行关联。\r\n\t* 贫血模型：老子知道儿子，儿子也知道老子；部分业务逻辑放到实体中；优点：各层单项依赖，结构清楚，易于维护；缺点：不符合OO思想，相比于充血模式，Service层较为厚重；\r\n\t* 充血模型：和贫血模型类似，区别在于如何划分业务逻辑。优点：Service层比较薄，只充当Facade的角色，不和DAO打交道、复合OO思想；缺点：非单项依赖，DO和DAO之间双向依赖、和Service层的逻辑划分容易造成混乱。\r\n\t* 肿胀模式：是一种极端情况，取消Service层、全部业务逻辑放在DO中；优点：符合OO思想、简化了分层；缺点：暴露信息过多、很多非DO逻辑也会强行并入DO。这种模式应该避免。\r\n\t* 作者主张使用贫血模式。\r\n\t\r\n## Actor 模式\r\n\r\nTODO\r\n\r\n## 响应式编程\r\n\r\n### Reactor\r\nTODO\r\n### RxJava\r\nTODO\r\n### Vert.x\r\nTODO\r\n\r\n## DODAF2.0\r\n\r\n* [《DODAF2.0方法论》](http://www.360doc.com/content/16/0627/19/33945750_571201779.shtml)\r\n* [《DODAF2.0之能力视角如何落地》](http://blog.51cto.com/xiaoyong/1553164)\r\n\r\n## Serverless\r\n\r\n无需过多关系服务器的服务架构理念。\r\n\r\n* [《什么是Serverless无服务器架构？》](http://www.jdon.com/soa/serverless.html)\r\n\t* Serverless 不代表出去服务器，而是去除对服务器运行状态的关心。\r\n\t* Serverless 代表一思维方式的转变，从“构建一套服务在一台服务器上，对对个事件进行响应转变为构建一个为服务器，来响应一个事件”。\r\n\t* Serverless 不代表某个具体的框架。\r\n\r\n* [《如何理解Serverless？》](http://www.infoq.com/cn/news/2017/10/how-to-understand-serverless)\r\n\t* 依赖于 Baas （(Mobile) Backend as a Service） 和 Faas （Functions as a service）\r\n\r\n\r\n\r\n## Service Mesh\r\n\r\n* [《什么是Service Mesh？》](https://time.geekbang.org/article/2355)\r\n* [《初识 Service Mesh》](https://www.jianshu.com/p/e23e3e74538e)\r\n\r\n* [《什么是Service Mesh？》](https://time.geekbang.org/article/2355)\r\n\r\n# 项目管理\r\n\r\n## 架构评审\r\n* [《架构设计之如何评审架构设计说明书》](http://developer.51cto.com/art/201506/478486.htm)\r\n* [《人人都是架构师：非功能性需求》](https://blog.csdn.net/wireless_com/article/details/45935591)\r\n\r\n## 重构\r\n\r\n* [《架构之重构的12条军规》](http://www.infoq.com/cn/articles/architect-12-rules-complete/)\r\n\r\n## 代码规范\r\n\r\n* [《阿里巴巴Java开发手册》](https://github.com/alibaba/p3c)\r\n\r\n## 代码 Review\r\n\r\n\r\n制度还是制度!\r\n另外，每个公司需要根据自己的需求和目标制定自己的 check list\r\n\r\n* [《为什么你做不好 Code Review？》](http://www.sohu.com/a/229745352_181657)\r\n\t* 代码 review 做的好，在于制度建设。\r\n\r\n* [《从零开始Code Review》](https://blog.csdn.net/uxyheaven/article/details/49773619)\r\n\r\n* [《Code Review Checklist》](https://www.cnblogs.com/zuoping/p/5477047.html)\r\n* [《Java Code Review Checklist》](https://dzone.com/articles/java-code-review-checklist)\r\n\r\n* [《如何用 gitlab 做 code review》](https://blog.csdn.net/legend0011/article/details/45585575)\r\n\r\n## RUP\r\n* [《运用RUP 4+1视图方法进行软件架构设计》](https://blog.csdn.net/apanious/article/details/51011946)\r\n\r\n## 看板管理\r\n* [《说说看板在项目中的应用》](https://blog.csdn.net/tkchen/article/details/51637643)\r\n\r\n## SCRUM\r\n\r\nSCRUM - 争球\r\n\r\n* 3个角色:Product Owner(PO) 产品负责人;Scrum Master（SM），推动Scrum执行;Team 开发团队。\r\n* 3个工件：Product Backlog 产品TODOLIST，含优先级;Sprint Backlog 功能开发 TODO LIST；燃尽图；\r\n* 五个价值观：专注、勇气、公开、承诺、尊重。\r\n\r\n\r\n* [《敏捷项目管理流程-Scrum框架最全总结！》](https://blog.csdn.net/inny100_100/article/details/54633757)\r\n\r\n* [《敏捷其实很简单3---敏捷方法之scrum》](https://blog.csdn.net/superkunkun/article/details/52951142)\r\n\r\n## 敏捷开发\r\n\r\nTODO\r\n\r\n## 极限编程（XP）\r\n\r\nXP - eXtreme Programming\r\n\r\n* [《主流敏捷开发方法：极限编程XP》](http://www.woshipm.com/pmd/406917.html)\r\n\t* 是一种指导开发人员的方法论。\r\n\t* 4大价值：\r\n\t\t* 沟通：鼓励口头沟通，提高效率。\r\n\t\t* 简单：够用就好。\r\n\t\t* 反馈：及时反馈、通知相关人。\r\n\t\t* 勇气：提倡拥抱变化，敢于重构。\r\n\t\t\r\n\t* 5个原则：快速反馈、简单性假设、逐步修改、提倡更改（小步快跑）、优质工作（保证质量的前提下保证小步快跑）。\r\n\t* 5个工作：阶段性冲刺；冲刺计划会议；每日站立会议；冲刺后review；回顾会议。\r\n\r\n## 结对编程\r\n\r\n边写码，边review。能够增强代码质量、减少bug。\r\n\r\n* [《结对编程》](http://www.baike.com/wiki/%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B)\r\n\r\n## PDCA 循环质量管理\r\n\r\nP——PLAN 策划，D——DO 实施，C——CHECK 检查，A——ACT 改进\r\n\r\n* [《PDCA》](http://www.baike.com/wiki/PDCA)\r\n\r\n## FMEA管理模式\r\n\r\nTODO\r\n\r\n# 通用业务术语\r\n\r\nTODO\r\n\r\n# 技术趋势\r\n\r\nTODO\r\n\r\n# 政策、法规\r\n\r\nTODO\r\n## 法律\r\n\r\n### 严格遵守刑法253法条\r\n\r\n我国刑法第253条之一规定：\r\n\r\n\u003e * 国家机关或者金融、电信、交通、教育、医疗等单位的工作人员，违反国家规定，将本单位在履行职责或者提供服务过程中获得的公民个人信息，出售或者非法提供给他人，情节严重的，处3年以下有期徒刑或者拘役，并处或者单处罚金。\r\n\u003e * 窃取或者以其他方法非法获取上述信息，情节严重的，依照前款的规定处罚。 \r\n\u003e * 单位犯前两款罪的，对单位判处罚金，并对其直接负责的主管人员和其他直接责任人员，依照各该款的规定处罚。\r\n\r\n最高人民法院、最高人民检察院关于执行《中华人民共和国刑法》确定罪名的补充规定（四）规定：触犯刑法第253条之一第1款之规定，构成“出售、非法提供公民个人信息罪”；触犯刑法第253条之一第2款之规定，构成“非法获取公民个人信息罪”\r\n\r\n* [《非法获取公民个人信息罪》](https://baike.baidu.com/item/%E9%9D%9E%E6%B3%95%E8%8E%B7%E5%8F%96%E5%85%AC%E6%B0%91%E4%B8%AA%E4%BA%BA%E4%BF%A1%E6%81%AF%E7%BD%AA)\r\n\r\n\r\n# 架构师素质\r\n\r\n* [《架构师画像》](http://hellojava.info/?p=430)\r\n\t* 业务理解和抽象能力\r\n\t* NB的代码能力\r\n\t* 全面：1. 在面对业务问题上，架构师脑海里是否会浮现出多种技术方案；2. 在做系统设计时是否考虑到了足够多的方方面面；3. 在做系统设计时是否考虑到了足够多的方方面面； \r\n\t* 全局：是否考虑到了对上下游的系统的影响。\r\n\t* 权衡：权衡投入产出比；优先级和节奏控制；\r\n\r\n* [《关于架构优化和设计，架构师必须知道的事情》](http://www.infoq.com/cn/articles/architecture-optimization-and-design-the-architect-must-know)\r\n\t* 要去考虑的细节：模块化、轻耦合、无共享架构；减少各个组件之前的依赖、注意服务之间依赖所有造成的链式失败及影响等。\r\n\t* 基础设施、配置、测试、开发、运维综合考虑。\r\n\t* 考虑人、团队、和组织的影响。 \r\n\r\n* [《如何才能真正的提高自己，成为一名出色的架构师？》](https://www.zhihu.com/question/19841397) \r\n\r\n* [《架构师的必备素质和成长途径》](https://blog.csdn.net/sanbingyutuoniao123/article/details/54144129)\r\n\t* 素质：业务理解、技术广度、技术深度、丰富经验、沟通能力、动手能力、美学素养。\r\n\t* 成长路径：2年积累知识、4年积累技能和组内影响力、7年积累部门内影响力、7年以上积累跨部门影响力。 \r\n\r\n* [《架构设计师—你在哪层楼？》](http://blog.51cto.com/frankfan/1248401)\r\n\t* 第一层的架构师看到的只是产品本身\r\n\t* 第二层的架构师不仅看到自己的产品，还看到了整体的方案\r\n\t* 第三层的架构师看到的是商业价值 \r\n\r\n# 团队管理\r\n\r\nTODO\r\n\r\n## 招聘\r\n\r\n# 资讯\r\n\r\n## 行业资讯\r\n\r\n* [36kr](http://36kr.com/)\r\n* [Techweb](http://www.techweb.com.cn/)\r\n\r\n## 公众号列表\r\n\r\nTODO\r\n\r\n## 博客\r\n\r\n### 团队博客\r\n* [阿里中间件博客](http://jm.taobao.org/)\r\n* [美团点评技术团队博客](https://tech.meituan.com)\r\n\r\n### 个人博客\r\n\r\n* [阮一峰的网络日志](http://www.ruanyifeng.com/)\r\n* [酷壳 - COOLSHELL-陈皓](https://coolshell.cn/)\r\n* [hellojava-阿里毕玄](http://hellojava.info/)\r\n* [Cm's Blog](http://cmsblogs.com/)\r\n* [程序猿DD-翟永超-《Spring Cloud微服务实战》作者](http://blog.didispace.com/)\r\n\r\n## 综合门户、社区\r\n\r\n**国内：**\r\n\r\n* [CSDN](http://csdn.net)\r\n\t 老牌技术社区、不必解释。\r\n* [51cto.com](http://www.51cto.com/)\r\n* [ITeye](http://www.iteye.com/)\r\n\t* 偏 Java 方向 \r\n* [博客园](https://www.cnblogs.com)\r\n* [ChinaUnix](http://www.tom.net/)\r\n\t* 偏 Linux 方向 \r\n* [开源中国社区](https://www.oschina.net/)\r\n* [深度开源](http://www.open-open.com/)\r\n* [伯乐在线](http://www.jobbole.com/)\r\n\t* 涵盖 IT职场、Web前端、后端、移动端、数据库等方面内容，偏技术端。\r\n\r\n* [ITPUB](http://www.itpub.net/)\r\n* [腾讯云— 云+社区](https://cloud.tencent.com/developer/column)\r\n* [阿里云— 云栖社区](https://yq.aliyun.com/)\r\n* [IBM DeveloperWorks](https://www.ibm.com/developerworks/cn/)\r\n* [开发者头条](https://toutiao.io/)\r\n* [LinkedKeeper](http://www.linkedkeeper.com)\r\n\r\n**国外：**\r\n\r\n* [DZone](https://dzone.com)\r\n* [Reddit](https://www.reddit.com)\r\n\r\n## 问答、讨论类社区\r\n\r\n* [segmentfault](https://segmentfault.com)\r\n\t* 问答+专栏 \r\n* [知乎](https://www.zhihu.com/)\r\n* [stackoverflow](https://stackoverflow.com/)\r\n\r\n## 行业数据分析\r\n\r\n* [艾瑞网](http://report.iresearch.cn/)\r\n* [QUEST MOBILE](https://www.questmobile.com.cn)\r\n\r\n* [国家数据](http://data.stats.gov.cn/)\r\n\r\n* [TalkingData](http://www.talkingdata.com/)\r\n\r\n## 专项网站\r\n\r\n* 测试:\r\n\t* [领测国际](http://www.ltesting.net/) \r\n\t* [测试窝](https://www.testwo.com/)\r\n\t* [TesterHome](https://testerhome.com)\r\n\r\n* 运维:\r\n  \t* [运维派](http://www.yunweipai.com/) \r\n  \t* [Abcdocker](https://www.abcdocker.com/)\r\n  \r\n* Java:\r\n\t* [ImportNew](http://www.importnew.com/)\r\n\t\t* 专注于 Java 技术分享\r\n\t* [HowToDoInJava](https://howtodoinjava.com/)\r\n\t\t* 英文博客\r\n\t\r\n* 安全\r\n\t* [红黑联盟](https://www.2cto.com/) \r\n\t* [FreeBuf](http://www.freebuf.com/)\r\n\r\n* 大数据\r\n\t* [中国大数据](http://www.thebigdata.cn/) \r\n\r\n* 其他专题网站：\r\n\t* [DockerInfo](http://www.dockerinfo.net/)\r\n\t\t* 专注于 Docker 应用及咨询、教程的网站。\r\n\t* [Linux公社](https://www.linuxidc.com/)\r\n\t\t* Linux 主题社区\r\n\r\n## 其他类\r\n\r\n* [程序员技能图谱](https://github.com/TeamStuQ/skill-map)\r\n\r\n## 推荐参考书\r\n\r\n\r\n### 在线电子书\r\n\r\n* [《深入理解Spring Cloud与微服务构建》](https://github.com/forezp/SpringCloudLearning)\r\n\r\n\r\n* [《阿里技术参考图册-研发篇》](http://techforum-img.cn-hangzhou.oss-pub.aliyun-inc.com/1523849261680/AliTech101_RD.pdf)\r\n* [《阿里技术参考图册-算法篇》](http://techforum-img.cn-hangzhou.oss-pub.aliyun-inc.com/1523848064814/AliTech101_Algorithms.pdf)\r\n\r\n* [《2018美团点评技术年货（合辑）》70M](http://dpurl.cn/n/1lqcX)\r\n\r\n* [InfoQ《架构师》月刊](http://www.infoq.com/cn/architect/)\r\n\r\n* [《架构师之路》](https://www.w3cschool.cn/architectroad/)\r\n\r\n### 纸质书\r\n\r\n#### 开发方面\r\n\r\n* 《阿里巴巴Java开发手册》[京东](https://union-click.jd.com/jdc?d=bVKwZQ) [淘宝](https://s.taobao.com/search?q=阿里巴巴Java开发手册)\r\n\r\n#### 架构方面\r\n* 《软件架构师的12项修炼：技术技能篇》[京东](https://union-click.jd.com/jdc?d=gXvRd8) [淘宝](https://s.taobao.com/search?q=软件架构师的12项修炼：技术技能篇)\r\n* 《架构之美》[京东](https://union-click.jd.com/jdc?d=xJit5I) [淘宝](https://s.taobao.com/search?q=架构之美)\r\n* 《分布式服务架构》[京东](https://union-click.jd.com/jdc?d=JS5Od9) [淘宝](https://s.taobao.com/search?q=分布式服务架构)\r\n* 《聊聊架构》 [京东](https://union-click.jd.com/jdc?d=FHooH4) [淘宝](https://s.taobao.com/search?q=聊聊架构)\r\n* 《云原生应用架构实践》[京东](https://union-click.jd.com/jdc?d=orkJSj) [淘宝](https://s.taobao.com/search?q=云原生应用架构实践)\r\n* 《亿级流量网站架构核心技术》[京东](https://union-click.jd.com/jdc?d=RnOSP5) [淘宝](https://s.taobao.com/search?q=亿级流量网站架构核心技术)\r\n* 《淘宝技术这十年》[京东](https://union-click.jd.com/jdc?d=LwrDfD) [淘宝](https://s.taobao.com/search?q=淘宝技术这十年)\r\n* 《企业IT架构转型之道-中台战略思想与架构实战》 [京东](https://union-click.jd.com/jdc?d=89pAEm) [淘宝](https://s.taobao.com/search?q=企业IT架构转型之道)\r\n\r\n* 《高可用架构（第1卷）》[京东](https://item.jd.com/12195481.html) [淘宝](https://s.taobao.com/search?q=高可用架构)\r\n\r\n#### 技术管理方面\r\n* 《CTO说》[京东](https://union-click.jd.com/jdc?d=zhTZyr) [淘宝](https://s.taobao.com/search?q=CTO说)\r\n* 《技术管理之巅》[京东](https://union-click.jd.com/jdc?d=LgRBUW) [淘宝](https://s.taobao.com/search?q=技术管理之巅)\r\n* 《网易一千零一夜：互联网产品项目管理实战》[京东](https://union-click.jd.com/jdc?d=jcRz2r) [淘宝](https://s.taobao.com/search?q=网易一千零一夜：互联网产品项目管理实战)\r\n\r\n#### 基础理论\r\n* 《数学之美》[京东](https://union-click.jd.com/jdc?d=ghIES2) [淘宝](https://s.taobao.com/search?q=数学之美)\r\n* 《编程珠玑》[京东](https://union-click.jd.com/jdc?d=YmhdEu) [淘宝](https://s.taobao.com/search?q=编程珠玑)\r\n\r\n#### 工具方面\r\nTODO\r\n\r\n#### 大数据方面\r\n\r\n# 技术资源\r\n\r\n## 开源资源\r\n* [github](https://github.com)\r\n\r\n* [Apache 软件基金会](https://www.apache.org/index.html)\r\n\r\n## 手册、文档、教程\r\n\r\n**国内：**\r\n* [W3Cschool](http://w3cschool.cn) \r\n* [Runoob.com](http://www.runoob.com/)\r\n\t* HTML 、 CSS、XML、Java、Python、PHP、设计模式等入门手册。\r\n\r\n* [Love2.io](https://love2.io/)\r\n\t* 很多很多中文在线电子书，是一个全新的开源技术文档分享平台。\r\n* [gitbook.cn](http://gitbook.cn/)\r\n\t* 付费电子书。 \r\n* [ApacheCN](http://www.apachecn.org/)\r\n\t* AI、大数据方面系列中文文档。\r\n\r\n**国外：**\r\n\r\n* [Quick Code](http://www.quickcode.co/)\r\n\t* 免费在线技术教程。\r\n* [gitbook.com](http://gitbook.com)\r\n\t* 有部分中文电子书。\r\n* [Cheatography](https://www.cheatography.com/)\r\n\t* Cheat Sheets 大全，单页文档网站。\r\n* [Tutorialspoint](https://www.tutorialspoint.com/index.htm)\r\n\t* 知名教程网站，提供Java、Python、JS、SQL、大数据等高质量入门教程。\r\n\r\n\r\n## 在线课堂\r\n\r\n* [学徒无忧](http://www.xuetuwuyou.com/)\r\n* [极客时间](https://time.geekbang.org/)\r\n* [segmentfault](https://segmentfault.com/lives)\r\n* [斯达克学院](https://new.stuq.org/course/explore)\r\n* [牛客网](http://nowcoder.com)\r\n* [极客学院](https://www.jikexueyuan.com/)\r\n* [51CTO学院](http://edu.51cto.com/)\r\n\r\n## 会议、活动\r\n\r\n* [QCon](http://www.infoq.com/cn/qcon/)\r\n* [ArchSummit](https://archsummit.com)\r\n* [GITC全球互联网技术大会](http://www.thegitc.com/)\r\n\r\n**活动发布平台:** \r\n* [活动行](http://www.huodongxing.com/)\r\n\r\n## 常用APP\r\n\r\n* [极客时间](https://time.geekbang.org)\r\n* [得到](https://www.igetget.com)\r\n\r\n## 找工作\r\n* [Boss直聘](https://www.zhipin.com)\r\n* [拉勾网](https://www.lagou.com)\r\n* [猎聘](https://www.liepin.com)\r\n* [100Offer](https://cn.100offer.com/)\r\n\r\n## 工具\r\n\r\n* [极客搜索](https://s.geekbang.org/)\r\n\t* 技术文章搜索引擎。\r\n\r\n## 代码托管\r\n\r\n* [Coding](https://coding.net)\r\n* [码云](https://gitee.com/)\r\n\r\n## 文件服务\r\n* 七牛\r\n* 又拍云\r\n\r\n## 综合云服务商\r\n* 阿里云\r\n* [腾讯云](https://cloud.tencent.com/redirect.php?redirect=1012\u0026cps_key=c2665015d90871c0cb20fef91b7afc3c)\r\n* 百度云\r\n* 新浪云\r\n* 金山云\r\n* [亚马逊云(AWS)](https://amazonaws-china.com/cn/)\r\n* [谷歌云](https://cloud.google.com/?hl=zh-cn)\r\n* [微软云](https://azure.microsoft.com/zh-cn/)\r\n\r\n### VPS\r\n* [Linode](http://linode.com)\r\n\r\n","cover":"https://images.pexels.com/photos/39284/macbook-apple-imac-computer-39284.jpeg?auto=compress\u0026cs=tinysrgb\u0026dpr=2\u0026h=280\u0026w=370","link":"后端架构师技术图谱.html","preview":"","title":"后端架构师技术图谱"},{"content":"\r\n\r\n原文转自[寻找一种易于理解的一致性算法（扩展版）](https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md)，部分图片有遗漏，暂未整理\r\n\r\n## 摘要\r\n\r\nRaft 是一种为了管理复制日志的一致性算法。它提供了和 Paxos 算法相同的功能和性能，但是它的算法结构和 Paxos 不同，使得 Raft 算法更加容易理解并且更容易构建实际的系统。为了提升可理解性，Raft 将一致性算法分解成了几个关键模块，例如领导人选举、日志复制和安全性。同时它通过实施一个更强的一致性来减少需要考虑的状态的数量。从一个用户研究的结果可以证明，对于学生而言，Raft 算法比 Paxos 算法更加容易学习。Raft 算法还包括一个新的机制来允许集群成员的动态改变，它利用重叠的大多数来保证安全性。\r\n\r\n## 1 介绍\r\n\r\n一致性算法允许一组机器像一个整体一样工作，即使其中一些机器出现故障也能够继续工作下去。正因为如此，一致性算法在构建可信赖的大规模软件系统中扮演着重要的角色。在过去的 10 年里，Paxos  算法统治着一致性算法这一领域：绝大多数的实现都是基于 Paxos 或者受其影响。同时 Paxos 也成为了教学领域里讲解一致性问题时的示例。\r\n\r\n但是不幸的是，尽管有很多工作都在尝试降低它的复杂性，但是 Paxos 算法依然十分难以理解。并且，Paxos 自身的算法结构需要进行大幅的修改才能够应用到实际的系统中。这些都导致了工业界和学术界都对 Paxos 算法感到十分头疼。\r\n\r\n和 Paxos 算法进行过努力之后，我们开始寻找一种新的一致性算法，可以为构建实际的系统和教学提供更好的基础。我们的做法是不寻常的，我们的首要目标是可理解性：我们是否可以在实际系统中定义一个一致性算法，并且能够比 Paxos 算法以一种更加容易的方式来学习。此外，我们希望该算法方便系统构建者的直觉的发展。不仅一个算法能够工作很重要，而且能够显而易见的知道为什么能工作也很重要。\r\n\r\nRaft 一致性算法就是这些工作的结果。在设计 Raft 算法的时候，我们使用一些特别的技巧来提升它的可理解性，包括算法分解（Raft 主要被分成了领导人选举，日志复制和安全三个模块）和减少状态机的状态（相对于 Paxos，Raft 减少了非确定性和服务器互相处于非一致性的方式）。一份针对两所大学 43 个学生的研究表明 Raft 明显比 Paxos 算法更加容易理解。在这些学生同时学习了这两种算法之后，和 Paxos 比起来，其中 33 个学生能够回答有关于 Raft 的问题。\r\n\r\nRaft 算法在许多方面和现有的一致性算法都很相似（主要是 Oki 和 Liskov 的 Viewstamped Replication），但是它也有一些独特的特性：\r\n\r\n* **强领导者**：和其他一致性算法相比，Raft 使用一种更强的领导能力形式。比如，日志条目只从领导者发送给其他的服务器。这种方式简化了对复制日志的管理并且使得 Raft 算法更加易于理解。\r\n* **领导选举**：Raft 算法使用一个随机计时器来选举领导者。这种方式只是在任何一致性算法都必须实现的心跳机制上增加了一点机制。在解决冲突的时候会更加简单快捷。\r\n* **成员关系调整**：Raft 使用一种共同一致的方法来处理集群成员变换的问题，在这种方法下，处于调整过程中的两种不同的配置集群中大多数机器会有重叠，这就使得集群在成员变换的时候依然可以继续工作。\r\n\r\n我们相信，Raft 算法不论出于教学目的还是作为实践项目的基础都是要比 Paxos 或者其他一致性算法要优异的。它比其他算法更加简单，更加容易理解；它的算法描述足以实现一个现实的系统；它有好多开源的实现并且在很多公司里使用；它的安全性已经被证明；它的效率和其他算法比起来也不相上下。\r\n\r\n接下来，这篇论文会介绍以下内容：复制状态机问题（第 2 节），讨论 Paxos 的优点和缺点（第 3 节），讨论我们为了理解能力而使用的方法（第 4 节），阐述 Raft 一致性算法（第 5-8 节），评价 Raft 算法（第 9 节），以及一些相关的工作（第 10 节）。\r\n\r\n## 2 复制状态机\r\n\r\n一致性算法是从复制状态机的背景下提出的（参考英文原文引用37）。在这种方法中，一组服务器上的状态机产生相同状态的副本，并且在一些机器宕掉的情况下也可以继续运行。复制状态机在分布式系统中被用于解决很多容错的问题。例如，大规模的系统中通常都有一个集群领导者，像 GFS、HDFS 和 RAMCloud，典型应用就是一个独立的的复制状态机去管理领导选举和存储配置信息并且在领导人宕机的情况下也要存活下来。比如 Chubby 和 ZooKeeper。\r\n\r\n![图 1](https://camo.githubusercontent.com/ad683fbaefbc0bc0fcb31b1d6ca6ca8f715c12cd/68747470733a2f2f646e2d307830312d696f2e71626f782e6d652f726166742d254535253942254245312d30312e706e67)\r\n\r\n\u003e 图 1 ：复制状态机的结构。一致性算法管理着来自客户端指令的复制日志。状态机从日志中处理相同顺序的相同指令，所以产生的结果也是相同的。\r\n\r\n复制状态机通常都是基于复制日志实现的，如图 1。每一个服务器存储一个包含一系列指令的日志，并且按照日志的顺序进行执行。每一个日志都按照相同的顺序包含相同的指令，所以每一个服务器都执行相同的指令序列。因为每个状态机都是确定的，每一次执行操作都产生相同的状态和同样的序列。\r\n\r\n保证复制日志相同就是一致性算法的工作了。在一台服务器上，一致性模块接收客户端发送来的指令然后增加到自己的日志中去。它和其他服务器上的一致性模块进行通信来保证每一个服务器上的日志最终都以相同的顺序包含相同的请求，尽管有些服务器会宕机。一旦指令被正确的复制，每一个服务器的状态机按照日志顺序处理他们，然后输出结果被返回给客户端。因此，服务器集群看起来形成一个高可靠的状态机。\r\n\r\n实际系统中使用的一致性算法通常含有以下特性：\r\n\r\n* 安全性保证（绝对不会返回一个错误的结果）：在非拜占庭错误情况下，包括网络延迟、分区、丢包、冗余和乱序等错误都可以保证正确。\r\n* 可用性：集群中只要有大多数的机器可运行并且能够相互通信、和客户端通信，就可以保证可用。因此，一个典型的包含 5 个节点的集群可以容忍两个节点的失败。服务器被停止就认为是失败。他们当有稳定的存储的时候可以从状态中恢复回来并重新加入集群。\r\n* 不依赖时序来保证一致性：物理时钟错误或者极端的消息延迟在可能只有在最坏情况下才会导致可用性问题。\r\n* 通常情况下，一条指令可以尽可能快的在集群中大多数节点响应一轮远程过程调用时完成。小部分比较慢的节点不会影响系统整体的性能。\r\n\r\n## 3 Paxos算法的问题\r\n\r\n在过去的 10 年里，Leslie Lamport 的 Paxos 算法几乎已经成为一致性的代名词：Paxos 是在课程教学中最经常使用的算法，同时也是大多数一致性算法实现的起点。Paxos 首先定义了一个能够达成单一决策一致的协议，比如单条的复制日志项。我们把这一子集叫做单决策 Paxos。然后通过组合多个 Paxos 协议的实例来促进一系列决策的达成。Paxos 保证安全性和活性，同时也支持集群成员关系的变更。Paxos 的正确性已经被证明，在通常情况下也很高效。\r\n\r\n不幸的是，Paxos 有两个明显的缺点。第一个缺点是 Paxos 算法特别的难以理解。完整的解释是出了名的不透明；通过极大的努力之后，也只有少数人成功理解了这个算法。因此，有了几次用更简单的术语来解释 Paxos 的尝试。尽管这些解释都只关注了单决策的子集问题，但依然很具有挑战性。在 2012 年 NSDI 的会议中的一次调查显示，很少有人对 Paxos 算法感到满意，甚至在经验老道的研究者中也是如此。我们自己也尝试去理解 Paxos；我们一直没能理解 Paxos 直到我们读了很多对 Paxos 的简化解释并且设计了我们自己的算法之后，这一过程花了近一年时间。\r\n\r\n我们假设 Paxos 的不透明性来自它选择单决策问题作为它的基础。单决策 Paxos 是晦涩微妙的，它被划分成了两种没有简单直观解释和无法独立理解的情景。因此，这导致了很难建立起直观的感受为什么单决策 Paxos 算法能够工作。构成多决策 Paxos 增加了很多错综复杂的规则。我们相信，在多决策上达成一致性的问题（一份日志而不是单一的日志记录）能够被分解成其他的方式并且更加直接和明显。\r\n\r\nPaxos算法的第二个问题就是它没有提供一个足够好的用来构建一个现实系统的基础。一个原因是还没有一种被广泛认同的多决策问题的算法。Lamport 的描述基本上都是关于单决策 Paxos 的；他简要描述了实施多决策 Paxos 的方法，但是缺乏很多细节。当然也有很多具体化 Paxos 的尝试，但是他们都互相不一样，和 Paxos 的概述也不同。例如 Chubby 这样的系统实现了一个类似于 Paxos 的算法，但是大多数的细节并没有被公开。\r\n\r\n而且，Paxos 算法的结构也不是十分易于构建实践的系统；单决策分解也会产生其他的结果。例如，独立的选择一组日志条目然后合并成一个序列化的日志并没有带来太多的好处，仅仅增加了不少复杂性。围绕着日志来设计一个系统是更加简单高效的；新日志条目以严格限制的顺序增添到日志中去。另一个问题是，Paxos 使用了一种对等的点对点的方式作为它的核心（尽管它最终提议了一种弱领导人的方法来优化性能）。在只有一个决策会被制定的简化世界中是很有意义的，但是很少有现实的系统使用这种方式。如果有一系列的决策需要被制定，首先选择一个领导人，然后让他去协调所有的决议，会更加简单快速。\r\n\r\n因此，实际的系统中很少有和 Paxos 相似的实践。每一种实现都是从 Paxos 开始研究，然后发现很多实现上的难题，再然后开发了一种和 Paxos 明显不一样的结构。这样是非常费时和容易出错的，并且理解 Paxos 的难度使得这个问题更加糟糕。Paxos 算法在理论上被证明是正确可行的，但是现实的系统和 Paxos 差别是如此的大，以至于这些证明没有什么太大的价值。下面来自 Chubby 实现非常典型：\r\n\r\n\u003e 在Paxos算法描述和实现现实系统中间有者巨大的鸿沟。最终的系统建立在一种没有经过证明的算法之上。\r\n\r\n由于以上问题，我们认为 Paxos 算法既没有提供一个良好的基础给实践的系统，也没有给教学很好的帮助。基于一致性问题在大规模软件系统中的重要性，我们决定看看我们是否可以设计一个拥有更好特性的替代 Paxos 的一致性算法。Raft算法就是这次实验的结果。\r\n\r\n## 4 为了可理解性的设计\r\n\r\n设计 Raft 算法我们有几个初衷：它必须提供一个完整的实际的系统实现基础，这样才能大大减少开发者的工作；它必须在任何情况下都是安全的并且在大多数的情况下都是可用的；并且它的大部分操作必须是高效的。但是我们最重要也是最大的挑战是可理解性。它必须保证对于普遍的人群都可以十分容易的去理解。另外，它必须能够让人形成直观的认识，这样系统的构建者才能够在现实中进行必然的扩展。\r\n\r\n在设计 Raft 算法的时候，有很多的点需要我们在各种备选方案中进行选择。在这种情况下，我们评估备选方案基于可理解性原则：解释各个备选方案有多大的难度（例如，Raft 的状态空间有多复杂，是否有微妙的暗示）？对于一个读者而言，完全理解这个方案和暗示是否容易？\r\n\r\n我们意识到对这种可理解性分析上具有高度的主观性；尽管如此，我们使用了两种通常适用的技术来解决这个问题。第一个技术就是众所周知的问题分解：只要有可能，我们就将问题分解成几个相对独立的，可被解决的、可解释的和可理解的子问题。例如，Raft 算法被我们分成领导人选举，日志复制，安全性和角色改变几个部分。\r\n\r\n我们使用的第二个方法是通过减少状态的数量来简化需要考虑的状态空间，使得系统更加连贯并且在可能的时候消除不确定性。特别的，所有的日志是不允许有空洞的，并且 Raft 限制了日志之间变成不一致状态的可能。尽管在大多数情况下我们都试图去消除不确定性，但是也有一些情况下不确定性可以提升可理解性。尤其是，随机化方法增加了不确定性，但是他们有利于减少状态空间数量，通过处理所有可能选择时使用相似的方法。我们使用随机化去简化 Raft 中领导人选举算法。\r\n\r\n## 5 Raft 一致性算法\r\n\r\nRaft 是一种用来管理章节 2 中描述的复制日志的算法。图 2 为了参考之用，总结这个算法的简略版本，图 3 列举了这个算法的一些关键特性。图中的这些元素会在剩下的章节逐一介绍。\r\n\r\nRaft 通过选举一个高贵的领导人，然后给予他全部的管理复制日志的责任来实现一致性。领导人从客户端接收日志条目，把日志条目复制到其他服务器上，并且当保证安全性的时候告诉其他的服务器应用日志条目到他们的状态机中。拥有一个领导人大大简化了对复制日志的管理。例如，领导人可以决定新的日志条目需要放在日志中的什么位置而不需要和其他服务器商议，并且数据都从领导人流向其他服务器。一个领导人可以宕机，可以和其他服务器失去连接，这时一个新的领导人会被选举出来。\r\n\r\n通过领导人的方式，Raft 将一致性问题分解成了三个相对独立的子问题，这些问题会在接下来的子章节中进行讨论：\r\n\r\n* **领导选举**：一个新的领导人需要被选举出来，当现存的领导人宕机的时候（章节 5.2）\r\n* **日志复制**：领导人必须从客户端接收日志然后复制到集群中的其他节点，并且强制要求其他节点的日志保持和自己相同。\r\n* **安全性**：在 Raft 中安全性的关键是在图 3 中展示的状态机安全：如果有任何的服务器节点已经应用了一个确定的日志条目到它的状态机中，那么其他服务器节点不能在同一个日志索引位置应用一个不同的指令。章节 5.4 阐述了 Raft 算法是如何保证这个特性的；这个解决方案涉及到一个额外的选举机制（5.2 节）上的限制。\r\n\r\n在展示一致性算法之后，这一章节会讨论可用性的一些问题和系统中的候选人角色的问题。\r\n\r\n**状态**：\r\n\r\n|状态|所有服务器上持久存在的|\r\n|-------|------|\r\n|currentTerm | 服务器最后一次知道的任期号（初始化为 0，持续递增）|\r\n|votedFor | 在当前获得选票的候选人的 Id|\r\n| log[] | 日志条目集；每一个条目包含一个用户状态机执行的指令，和收到时的任期号 |\r\n\r\n|状态|所有服务器上经常变的|\r\n|-------|------|\r\n| commitIndex| 已知的最大的已经被提交的日志条目的索引值|\r\n| lastApplied| 最后被应用到状态机的日志条目索引值（初始化为 0，持续递增）|\r\n\r\n| 状态 | 在领导人里经常改变的 （选举后重新初始化）|\r\n|----|--------|\r\n| nextIndex[] | 对于每一个服务器，需要发送给他的下一个日志条目的索引值（初始化为领导人最后索引值加一）|\r\n| matchIndex[] | 对于每一个服务器，已经复制给他的日志的最高索引值|\r\n\r\n\r\n**附加日志 RPC**：\r\n\r\n由领导人负责调用来复制日志指令；也会用作heartbeat\r\n\r\n| 参数 | 解释 |\r\n|----|----|\r\n|term| 领导人的任期号|\r\n|leaderId| 领导人的 Id，以便于跟随者重定向请求|\r\n|prevLogIndex|新的日志条目紧随之前的索引值|\r\n|prevLogTerm|prevLogIndex 条目的任期号|\r\n|entries[]|准备存储的日志条目（表示心跳时为空；一次性发送多个是为了提高效率）\r\n|leaderCommit|领导人已经提交的日志的索引值|\r\n\r\n| 返回值| 解释|\r\n|---|---|\r\n|term|当前的任期号，用于领导人去更新自己|\r\n|success|跟随者包含了匹配上 prevLogIndex 和 prevLogTerm 的日志时为真|\r\n\r\n接收者实现：\r\n\r\n1. 如果 `term \u003c currentTerm` 就返回 false （5.1 节）\r\n2. 如果日志在 prevLogIndex 位置处的日志条目的任期号和 prevLogTerm 不匹配，则返回 false （5.3 节）\r\n3. 如果已经存在的日志条目和新的产生冲突（索引值相同但是任期号不同），删除这一条和之后所有的 （5.3 节）\r\n4. 附加任何在已有的日志中不存在的条目\r\n5. 如果 `leaderCommit \u003e commitIndex`，令 commitIndex 等于 leaderCommit 和 新日志条目索引值中较小的一个\r\n\r\n**请求投票 RPC**：\r\n\r\n由候选人负责调用用来征集选票（5.2 节）\r\n\r\n| 参数 | 解释|\r\n|---|---|\r\n|term| 候选人的任期号|\r\n|candidateId| 请求选票的候选人的 Id |\r\n|lastLogIndex| 候选人的最后日志条目的索引值|\r\n|lastLogTerm| 候选人最后日志条目的任期号|\r\n\r\n| 返回值| 解释|\r\n|---|---|\r\n|term| 当前任期号，以便于候选人去更新自己的任期号|\r\n|voteGranted| 候选人赢得了此张选票时为真|\r\n\r\n接收者实现：\r\n\r\n1. 如果`term \u003c currentTerm`返回 false （5.2 节）\r\n2. 如果 votedFor 为空或者就是 candidateId，并且候选人的日志至少和自己一样新，那么就投票给他（5.2 节，5.4 节）\r\n\r\n**所有服务器需遵守的规则**：\r\n\r\n所有服务器：\r\n\r\n* 如果`commitIndex \u003e lastApplied`，那么就 lastApplied 加一，并把`log[lastApplied]`应用到状态机中（5.3 节）\r\n* 如果接收到的 RPC 请求或响应中，任期号`T \u003e currentTerm`，那么就令 currentTerm 等于 T，并切换状态为跟随者（5.1 节）\r\n\r\n跟随者（5.2 节）：\r\n\r\n* 响应来自候选人和领导者的请求\r\n* 如果在超过选举超时时间的情况之前都没有收到领导人的心跳，或者是候选人请求投票的，就自己变成候选人\r\n\r\n候选人（5.2 节）：\r\n\r\n* 在转变成候选人后就立即开始选举过程\r\n\t* 自增当前的任期号（currentTerm）\r\n\t* 给自己投票\r\n\t* 重置选举超时计时器\r\n\t* 发送请求投票的 RPC 给其他所有服务器\r\n* 如果接收到大多数服务器的选票，那么就变成领导人\r\n* 如果接收到来自新的领导人的附加日志 RPC，转变成跟随者\r\n* 如果选举过程超时，再次发起一轮选举\r\n\r\n领导人：\r\n\r\n* 一旦成为领导人：发送空的附加日志 RPC（心跳）给其他所有的服务器；在一定的空余时间之后不停的重复发送，以阻止跟随者超时（5.2 节）\r\n*  如果接收到来自客户端的请求：附加条目到本地日志中，在条目被应用到状态机后响应客户端（5.3 节）\r\n*  如果对于一个跟随者，最后日志条目的索引值大于等于 nextIndex，那么：发送从 nextIndex 开始的所有日志条目：\r\n\t* 如果成功：更新相应跟随者的 nextIndex 和 matchIndex\r\n\t* 如果因为日志不一致而失败，减少 nextIndex 重试\r\n* 如果存在一个满足`N \u003e commitIndex`的 N，并且大多数的`matchIndex[i] ≥ N`成立，并且`log[N].term == currentTerm`成立，那么令 commitIndex 等于这个 N （5.3 和 5.4 节）\r\n\r\n\u003e 图 2：一个关于 Raft 一致性算法的浓缩总结（不包括成员变换和日志压缩）。\r\n\r\n| 特性| 解释|\r\n|---|---|\r\n|选举安全特性| 对于一个给定的任期号，最多只会有一个领导人被选举出来（5.2 节）|\r\n|领导人只附加原则| 领导人绝对不会删除或者覆盖自己的日志，只会增加（5.3 节）|\r\n|日志匹配原则| 如果两个日志在相同的索引位置的日志条目的任期号相同，那么我们就认为这个日志从头到这个索引位置之间全部完全相同（5.3 节）\r\n|领导人完全特性|如果某个日志条目在某个任期号中已经被提交，那么这个条目必然出现在更大任期号的所有领导人中（5.4 节）|\r\n|状态机安全特性| 如果一个领导人已经在给定的索引值位置的日志条目应用到状态机中，那么其他任何的服务器在这个索引位置不会提交一个不同的日志（5.4.3 节）|\r\n\r\n\u003e 图 3：Raft 在任何时候都保证以上的各个特性。\r\n\r\n\r\n### 5.1 Raft 基础\r\n\r\n一个 Raft 集群包含若干个服务器节点；通常是 5 个，这允许整个系统容忍 2 个节点的失效。在任何时刻，每一个服务器节点都处于这三个状态之一：领导人、跟随者或者候选人。在通常情况下，系统中只有一个领导人并且其他的节点全部都是跟随者。跟随者都是被动的：他们不会发送任何请求，只是简单的响应来自领导者或者候选人的请求。领导人处理所有的客户端请求（如果一个客户端和跟随者联系，那么跟随者会把请求重定向给领导人）。第三种状态，候选人，是用来在 5.2 节描述的选举新领导人时使用。图 4 展示了这些状态和他们之间的转换关系；这些转换关系会在接下来进行讨论。\r\n\r\n![图 4 ](https://dn-0x01-io.qbox.me/raft-图4-01.png)\r\n\r\n\u003e 图 4：服务器状态。跟随者只响应来自其他服务器的请求。如果跟随者接收不到消息，那么他就会变成候选人并发起一次选举。获得集群中大多数选票的候选人将成为领导者。在一个任期内,领导人一直都会是领导人直到自己宕机了。\r\n\r\n![图 5](https://dn-0x01-io.qbox.me/raft-图5.png)\r\n\r\n\u003e 图 5：时间被划分成一个个的任期，每个任期开始都是一次选举。在选举成功后，领导人会管理整个集群直到任期结束。有时候选举会失败，那么这个任期就会没有领导人而结束。任期之间的切换可以在不同的时间不同的服务器上观察到。\r\n\r\nRaft 把时间分割成任意长度的**任期**，如图 5。任期用连续的整数标记。每一段任期从一次**选举**开始，就像章节 5.2 描述的一样，一个或者多个候选人尝试成为领导者。如果一个候选人赢得选举，然后他就在接下来的任期内充当领导人的职责。在某些情况下，一次选举过程会造成选票的瓜分。在这种情况下，这一任期会以没有领导人结束；一个新的任期（和一次新的选举）会很快重新开始。Raft 保证了在一个给定的任期内，最多只有一个领导者。\r\n\r\n不同的服务器节点可能多次观察到任期之间的转换，但在某些情况下，一个节点也可能观察不到任何一次选举或者整个任期全程。任期在 Raft 算法中充当逻辑时钟的作用，这会允许服务器节点查明一些过期的信息比如陈旧的领导者。每一个节点存储一个当前任期号，这一编号在整个时期内单调的增长。当服务器之间通信的时候会交换当前任期号；如果一个服务器的当前任期号比其他人小，那么他会更新自己的编号到较大的编号值。如果一个候选人或者领导者发现自己的任期号过期了，那么他会立即恢复成跟随者状态。如果一个节点接收到一个包含过期的任期号的请求，那么他会直接拒绝这个请求。\r\n\r\nRaft 算法中服务器节点之间通信使用远程过程调用（RPCs），并且基本的一致性算法只需要两种类型的 RPCs。请求投票（RequestVote） RPCs 由候选人在选举期间发起（章节  5.2），然后附加条目（AppendEntries）RPCs 由领导人发起，用来复制日志和提供一种心跳机制（章节 5.3）。第 7 节为了在服务器之间传输快照增加了第三种 RPC。当服务器没有及时的收到 RPC 的响应时，会进行重试， 并且他们能够并行的发起 RPCs 来获得最佳的性能。\r\n\r\n### 5.2 领导人选举\r\n\r\nRaft 使用一种心跳机制来触发领导人选举。当服务器程序启动时，他们都是跟随者身份。一个服务器节点继续保持着跟随者状态直到他从领导人或者候选者处接收到有效的 RPCs。领导者周期性的向所有跟随者发送心跳包（即不包含日志项内容的附加日志项 RPCs）来维持自己的权威。如果一个跟随者在一段时间里没有接收到任何消息，也就是**选举超时**，那么他就会认为系统中没有可用的领导者,并且发起选举以选出新的领导者。\r\n\r\n要开始一次选举过程，跟随者先要增加自己的当前任期号并且转换到候选人状态。然后他会并行的向集群中的其他服务器节点发送请求投票的 RPCs 来给自己投票。候选人会继续保持着当前状态直到以下三件事情之一发生：(a) 他自己赢得了这次的选举，(b) 其他的服务器成为领导者，(c) 一段时间之后没有任何一个获胜的人。这些结果会分别的在下面的段落里进行讨论。\r\n\r\n当一个候选人从整个集群的大多数服务器节点获得了针对同一个任期号的选票，那么他就赢得了这次选举并成为领导人。每一个服务器最多会对一个任期号投出一张选票，按照先来先服务的原则（注意：5.4 节在投票上增加了一点额外的限制）。要求大多数选票的规则确保了最多只会有一个候选人赢得此次选举（图 3 中的选举安全性）。一旦候选人赢得选举，他就立即成为领导人。然后他会向其他的服务器发送心跳消息来建立自己的权威并且阻止新的领导人的产生。\r\n\r\n在等待投票的时候，候选人可能会从其他的服务器接收到声明它是领导人的附加日志项 RPC。如果这个领导人的任期号（包含在此次的 RPC中）不小于候选人当前的任期号，那么候选人会承认领导人合法并回到跟随者状态。 如果此次 RPC 中的任期号比自己小，那么候选人就会拒绝这次的 RPC 并且继续保持候选人状态。\r\n\r\n第三种可能的结果是候选人既没有赢得选举也没有输：如果有多个跟随者同时成为候选人，那么选票可能会被瓜分以至于没有候选人可以赢得大多数人的支持。当这种情况发生的时候，每一个候选人都会超时，然后通过增加当前任期号来开始一轮新的选举。然而，没有其他机制的话，选票可能会被无限的重复瓜分。\r\n\r\nRaft 算法使用随机选举超时时间的方法来确保很少会发生选票瓜分的情况，就算发生也能很快的解决。为了阻止选票起初就被瓜分，选举超时时间是从一个固定的区间（例如 150-300毫秒）随机选择。这样可以把服务器都分散开以至于在大多数情况下只有一个服务器会选举超时；然后他赢得选举并在其他服务器超时之前发送心跳包。同样的机制被用在选票瓜分的情况下。每一个候选人在开始一次选举的时候会重置一个随机的选举超时时间，然后在超时时间内等待投票的结果；这样减少了在新的选举中另外的选票瓜分的可能性。9.3 节展示了这种方案能够快速的选出一个领导人。\r\n\r\n领导人选举这个例子,体现了可理解性原则是如何指导我们进行方案设计的。起初我们计划使用一种排名系统：每一个候选人都被赋予一个唯一的排名，供候选人之间竞争时进行选择。如果一个候选人发现另一个候选人拥有更高的排名，那么他就会回到跟随者状态，这样高排名的候选人能够更加容易的赢得下一次选举。但是我们发现这种方法在可用性方面会有一点问题（如果高排名的服务器宕机了，那么低排名的服务器可能会超时并再次进入候选人状态。而且如果这个行为发生得足够快，则可能会导致整个选举过程都被重置掉）。我们针对算法进行了多次调整，但是每次调整之后都会有新的问题。最终我们认为随机重试的方法是更加明显和易于理解的。\r\n\r\n### 5.3 日志复制\r\n\r\n一旦一个领导人被选举出来，他就开始为客户端提供服务。客户端的每一个请求都包含一条被复制状态机执行的指令。领导人把这条指令作为一条新的日志条目附加到日志中去，然后并行的发起附加条目 RPCs 给其他的服务器，让他们复制这条日志条目。当这条日志条目被安全的复制（下面会介绍），领导人会应用这条日志条目到它的状态机中然后把执行的结果返回给客户端。如果跟随者崩溃或者运行缓慢，再或者网络丢包，领导人会不断的重复尝试附加日志条目 RPCs （尽管已经回复了客户端）直到所有的跟随者都最终存储了所有的日志条目。\r\n\r\n![图 6](https://dn-0x01-io.qbox.me/raft-图6.png)\r\n\r\n\u003e 图 6：日志由有序序号标记的条目组成。每个条目都包含创建时的任期号（图中框中的数字），和一个状态机需要执行的指令。一个条目当可以安全的被应用到状态机中去的时候，就认为是可以提交了。\r\n\r\n日志以图 6 展示的方式组织。每一个日志条目存储一条状态机指令和从领导人收到这条指令时的任期号。日志中的任期号用来检查是否出现不一致的情况，同时也用来保证图 3 中的某些性质。每一条日志条目同时也都有一个整数索引值来表明它在日志中的位置。\r\n\r\n领导人来决定什么时候把日志条目应用到状态机中是安全的；这种日志条目被称为**已提交**。Raft 算法保证所有已提交的日志条目都是持久化的并且最终会被所有可用的状态机执行。在领导人将创建的日志条目复制到大多数的服务器上的时候，日志条目就会被提交（例如在图 6 中的条目 7）。同时，领导人的日志中之前的所有日志条目也都会被提交，包括由其他领导人创建的条目。5.4 节会讨论某些当在领导人改变之后应用这条规则的隐晦内容，同时他也展示了这种提交的定义是安全的。领导人跟踪了最大的将会被提交的日志项的索引，并且索引值会被包含在未来的所有附加日志 RPCs （包括心跳包），这样其他的服务器才能最终知道领导人的提交位置。一旦跟随者知道一条日志条目已经被提交，那么他也会将这个日志条目应用到本地的状态机中（按照日志的顺序）。\r\n\r\n我们设计了 Raft 的日志机制来维护一个不同服务器的日志之间的高层次的一致性。这么做不仅简化了系统的行为也使得更加可预计，同时他也是安全性保证的一个重要组件。Raft 维护着以下的特性，这些同时也组成了图 3 中的日志匹配特性：\r\n\r\n* 如果在不同的日志中的两个条目拥有相同的索引和任期号，那么他们存储了相同的指令。\r\n* 如果在不同的日志中的两个条目拥有相同的索引和任期号，那么他们之前的所有日志条目也全部相同。\r\n\r\n第一个特性来自这样的一个事实，领导人最多在一个任期里在指定的一个日志索引位置创建一条日志条目，同时日志条目在日志中的位置也从来不会改变。第二个特性由附加日志 RPC 的一个简单的一致性检查所保证。在发送附加日志 RPC 的时候，领导人会把新的日志条目紧接着之前的条目的索引位置和任期号包含在里面。如果跟随者在它的日志中找不到包含相同索引位置和任期号的条目，那么他就会拒绝接收新的日志条目。一致性检查就像一个归纳步骤：一开始空的日志状态肯定是满足日志匹配特性的，然后一致性检查保护了日志匹配特性当日志扩展的时候。因此，每当附加日志 RPC 返回成功时，领导人就知道跟随者的日志一定是和自己相同的了。\r\n\r\n\r\n在正常的操作中，领导人和跟随者的日志保持一致性，所以附加日志 RPC 的一致性检查从来不会失败。然而，领导人崩溃的情况会使得日志处于不一致的状态（老的领导人可能还没有完全复制所有的日志条目）。这种不一致问题会在领导人和跟随者的一系列崩溃下加剧。图 7 展示了跟随者的日志可能和新的领导人不同的方式。跟随者可能会丢失一些在新的领导人中有的日志条目，他也可能拥有一些领导人没有的日志条目，或者两者都发生。丢失或者多出日志条目可能会持续多个任期。\r\n\r\n![图 7](https://dn-0x01-io.qbox.me/raft-图7.png)\r\n\r\n\u003e 图 7：当一个领导人成功当选时，跟随者可能是任何情况（a-f）。每一个盒子表示是一个日志条目；里面的数字表示任期号。跟随者可能会缺少一些日志条目（a-b），可能会有一些未被提交的日志条目（c-d），或者两种情况都存在（e-f）。例如，场景 f 可能会这样发生，某服务器在任期 2 的时候是领导人，已附加了一些日志条目到自己的日志中，但在提交之前就崩溃了；很快这个机器就被重启了，在任期 3 重新被选为领导人，并且又增加了一些日志条目到自己的日志中；在任期 2 和任期 3 的日志被提交之前，这个服务器又宕机了，并且在接下来的几个任期里一直处于宕机状态。\r\n\r\n\r\n在 Raft 算法中，领导人处理不一致是通过强制跟随者直接复制自己的日志来解决了。这意味着在跟随者中的冲突的日志条目会被领导人的日志覆盖。5.4 节会阐述如何通过增加一些限制来使得这样的操作是安全的。\r\n\r\n要使得跟随者的日志进入和自己一致的状态，领导人必须找到最后两者达成一致的地方，然后删除从那个点之后的所有日志条目，发送自己的日志给跟随者。所有的这些操作都在进行附加日志 RPCs 的一致性检查时完成。领导人针对每一个跟随者维护了一个 **nextIndex**，这表示下一个需要发送给跟随者的日志条目的索引地址。当一个领导人刚获得权力的时候，他初始化所有的 nextIndex 值为自己的最后一条日志的index加1（图 7 中的 11）。如果一个跟随者的日志和领导人不一致，那么在下一次的附加日志 RPC 时的一致性检查就会失败。在被跟随者拒绝之后，领导人就会减小 nextIndex 值并进行重试。最终 nextIndex 会在某个位置使得领导人和跟随者的日志达成一致。当这种情况发生，附加日志 RPC 就会成功，这时就会把跟随者冲突的日志条目全部删除并且加上领导人的日志。一旦附加日志 RPC 成功，那么跟随者的日志就会和领导人保持一致，并且在接下来的任期里一直继续保持。\r\n\r\n如果需要的话，算法可以通过减少被拒绝的附加日志 RPCs 的次数来优化。例如，当附加日志 RPC 的请求被拒绝的时候，跟随者可以包含冲突的条目的任期号和自己存储的那个任期的最早的索引地址。借助这些信息，领导人可以减小 nextIndex 越过所有那个任期冲突的所有日志条目；这样就变成每个任期需要一次附加条目 RPC 而不是每个条目一次。在实践中，我们十分怀疑这种优化是否是必要的，因为失败是很少发生的并且也不大可能会有这么多不一致的日志。\r\n\r\n通过这种机制，领导人在获得权力的时候就不需要任何特殊的操作来恢复一致性。他只需要进行正常的操作，然后日志就能自动的在回复附加日志 RPC 的一致性检查失败的时候自动趋于一致。领导人从来不会覆盖或者删除自己的日志（图 3 的领导人只附加特性）。\r\n\r\n日志复制机制展示出了第 2 节中形容的一致性特性：Raft 能够接受，复制并应用新的日志条目只要大部分的机器是工作的；在通常的情况下，新的日志条目可以在一次 RPC 中被复制给集群中的大多数机器；并且单个的缓慢的跟随者不会影响整体的性能。\r\n\r\n### 5.4 安全性\r\n\r\n前面的章节里描述了 Raft 算法是如何选举和复制日志的。然而，到目前为止描述的机制并不能充分的保证每一个状态机会按照相同的顺序执行相同的指令。例如，一个跟随者可能会进入不可用状态同时领导人已经提交了若干的日志条目，然后这个跟随者可能会被选举为领导人并且覆盖这些日志条目；因此，不同的状态机可能会执行不同的指令序列。\r\n\r\n这一节通过在领导选举的时候增加一些限制来完善 Raft 算法。这一限制保证了任何的领导人对于给定的任期号，都拥有了之前任期的所有被提交的日志条目（图 3 中的领导人完整特性）。增加这一选举时的限制，我们对于提交时的规则也更加清晰。最终，我们将展示对于领导人完整特性的简要证明，并且说明领导人是如何领导复制状态机的做出正确行为的。\r\n\r\n#### 5.4.1 选举限制\r\n\r\n在任何基于领导人的一致性算法中，领导人都必须存储所有已经提交的日志条目。在某些一致性算法中，例如 Viewstamped Replication，某个节点即使是一开始并没有包含所有已经提交的日志条目，它也能被选为领导者。这些算法都包含一些额外的机制来识别丢失的日志条目并把他们传送给新的领导人，要么是在选举阶段要么在之后很快进行。不幸的是，这种方法会导致相当大的额外的机制和复杂性。Raft 使用了一种更加简单的方法，它可以保证所有之前的任期号中已经提交的日志条目在选举的时候都会出现在新的领导人中，不需要传送这些日志条目给领导人。这意味着日志条目的传送是单向的，只从领导人传给跟随者，并且领导人从不会覆盖自身本地日志中已经存在的条目。\r\n\r\nRaft 使用投票的方式来阻止一个候选人赢得选举除非这个候选人包含了所有已经提交的日志条目。候选人为了赢得选举必须联系集群中的大部分节点，这意味着每一个已经提交的日志条目在这些服务器节点中肯定存在于至少一个节点上。如果候选人的日志至少和大多数的服务器节点一样新（这个新的定义会在下面讨论），那么他一定持有了所有已经提交的日志条目。请求投票 RPC 实现了这样的限制： RPC 中包含了候选人的日志信息，然后投票人会拒绝掉那些日志没有自己新的投票请求。\r\n\r\nRaft 通过比较两份日志中最后一条日志条目的索引值和任期号定义谁的日志比较新。如果两份日志最后的条目的任期号不同，那么任期号大的日志更加新。如果两份日志最后的条目任期号相同，那么日志比较长的那个就更加新。\r\n\r\n#### 5.4.2 提交之前任期内的日志条目\r\n\r\n如同 5.3 节介绍的那样，领导人知道一条当前任期内的日志记录是可以被提交的，只要它被存储到了大多数的服务器上。如果一个领导人在提交日志条目之前崩溃了，未来后续的领导人会继续尝试复制这条日志记录。然而，一个领导人不能断定一个之前任期里的日志条目被保存到大多数服务器上的时候就一定已经提交了。图 8 展示了一种情况，一条已经被存储到大多数节点上的老日志条目，也依然有可能会被未来的领导人覆盖掉。\r\n\r\n![图 8](https://dn-0x01-io.qbox.me/raft-图8.png)\r\n\r\n\u003e 图 8：如图的时间序列展示了为什么领导人无法决定对老任期号的日志条目进行提交。在 (a) 中，S1 是领导者，部分的复制了索引位置 2 的日志条目。在 (b) 中，S1 崩溃了，然后 S5 在任期 3 里通过 S3、S4 和自己的选票赢得选举，然后从客户端接收了一条不一样的日志条目放在了索引 2 处。然后到 (c)，S5 又崩溃了；S1 重新启动，选举成功，开始复制日志。在这时，来自任期 2 的那条日志已经被复制到了集群中的大多数机器上，但是还没有被提交。如果 S1 在 (d) 中又崩溃了，S5 可以重新被选举成功（通过来自 S2，S3 和 S4 的选票），然后覆盖了他们在索引 2 处的日志。反之，如果在崩溃之前，S1 把自己主导的新任期里产生的日志条目复制到了大多数机器上，就如 (e) 中那样，那么在后面任期里面这些新的日志条目就会被提交（因为S5 就不可能选举成功）。 这样在同一时刻就同时保证了，之前的所有老的日志条目就会被提交。\r\n\r\n为了消除图 8 里描述的情况，Raft 永远不会通过计算副本数目的方式去提交一个之前任期内的日志条目。只有领导人当前任期里的日志条目通过计算副本数目可以被提交；一旦当前任期的日志条目以这种方式被提交，那么由于日志匹配特性，之前的日志条目也都会被间接的提交。在某些情况下，领导人可以安全的知道一个老的日志条目是否已经被提交（例如，该条目是否存储到所有服务器上），但是 Raft 为了简化问题使用一种更加保守的方法。\r\n\r\n当领导人复制之前任期里的日志时，Raft 会为所有日志保留原始的任期号, 这在提交规则上产生了额外的复杂性。在其他的一致性算法中，如果一个新的领导人要重新复制之前的任期里的日志时，它必须使用当前新的任期号。Raft 使用的方法更加容易辨别出日志，因为它可以随着时间和日志的变化对日志维护着同一个任期编号。另外，和其他的算法相比，Raft 中的新领导人只需要发送更少日志条目（其他算法中必须在他们被提交之前发送更多的冗余日志条目来为他们重新编号）。\r\n\r\n#### 5.4.3 安全性论证\r\n\r\n在给定了完整的 Raft 算法之后，我们现在可以更加精确的讨论领导人完整性特性（这一讨论基于 9.2 节的安全性证明）。我们假设领导人完全性特性是不存在的，然后我们推出矛盾来。假设任期 T 的领导人（领导人 T）在任期内提交了一条日志条目，但是这条日志条目没有被存储到未来某个任期的领导人的日志中。设大于 T 的最小任期 U 的领导人 U 没有这条日志条目。\r\n\r\n![图 9](https://dn-0x01-io.qbox.me/raft-图9.png)\r\n\r\n\u003e 图 9：如果 S1 （任期 T 的领导者）提交了一条新的日志在它的任期里，然后 S5 在之后的任期 U 里被选举为领导人，然后至少会有一个机器，如 S3，既拥有来自 S1 的日志，也给 S5 投票了。\r\n\r\n1. 在领导人 U 选举的时候一定没有那条被提交的日志条目（领导人从不会删除或者覆盖任何条目）。\r\n2. 领导人 T 复制这条日志条目给集群中的大多数节点，同时，领导人U 从集群中的大多数节点赢得了选票。因此，至少有一个节点（投票者、选民）同时接受了来自领导人T 的日志条目，并且给领导人U 投票了，如图 9。这个投票者是产生这个矛盾的关键。\r\n3. 这个投票者必须在给领导人 U 投票之前先接受了从领导人 T 发来的已经被提交的日志条目；否则他就会拒绝来自领导人 T 的附加日志请求（因为此时他的任期号会比 T 大）。\r\n4. 投票者在给领导人 U 投票时依然保有这条日志条目，因为任何中间的领导人都包含该日志条目（根据上述的假设），领导人从不会删除条目，并且跟随者只有和领导人冲突的时候才会删除条目。\r\n5. 投票者把自己选票投给领导人 U 时，领导人 U 的日志必须和投票者自己一样新。这就导致了两者矛盾之一。\r\n6. 首先，如果投票者和领导人 U 的最后一条日志的任期号相同，那么领导人 U 的日志至少和投票者一样长，所以领导人 U 的日志一定包含所有投票者的日志。这是另一处矛盾，因为投票者包含了那条已经被提交的日志条目，但是在上述的假设里，领导人 U 是不包含的。\r\n7. 除此之外，领导人 U 的最后一条日志的任期号就必须比投票人大了。此外，他也比 T 大，因为投票人的最后一条日志的任期号至少和 T 一样大（他包含了来自任期 T 的已提交的日志）。创建了领导人 U 最后一条日志的之前领导人一定已经包含了那条被提交的日志（根据上述假设，领导人 U 是第一个不包含该日志条目的领导人）。所以，根据日志匹配特性，领导人 U 一定也包含那条被提交当然日志，这里产生矛盾。\r\n8. 这里完成了矛盾。因此，所有比 T 大的领导人一定包含了所有来自 T 的已经被提交的日志。\r\n9. 日志匹配原则保证了未来的领导人也同时会包含被间接提交的条目，例如图 8 (d) 中的索引 2。\r\n\r\n通过领导人完全特性，我们就能证明图 3 中的状态机安全特性，即如果已经服务器已经在某个给定的索引值应用了日志条目到自己的状态机里，那么其他的服务器不会应用一个不一样的日志到同一个索引值上。在一个服务器应用一条日志条目到他自己的状态机中时，他的日志必须和领导人的日志，在该条目和之前的条目上相同，并且已经被提交。现在我们来考虑在任何一个服务器应用一个指定索引位置的日志的最小任期；日志完全特性保证拥有更高任期号的领导人会存储相同的日志条目，所以之后的任期里应用某个索引位置的日志条目也会是相同的值。因此，状态机安全特性是成立的。\r\n\r\n最后，Raft 要求服务器按照日志中索引位置顺序应用日志条目。和状态机安全特性结合起来看，这就意味着所有的服务器会应用相同的日志序列集到自己的状态机中，并且是按照相同的顺序。\r\n\r\n### 5.5 跟随者和候选人崩溃\r\n\r\n到目前为止，我们都只关注了领导人崩溃的情况。跟随者和候选人崩溃后的处理方式比领导人要简单的多，并且他们的处理方式是相同的。如果跟随者或者候选人崩溃了，那么后续发送给他们的 RPCs 都会失败。Raft 中处理这种失败就是简单的通过无限的重试；如果崩溃的机器重启了，那么这些 RPC 就会完整的成功。如果一个服务器在完成了一个 RPC，但是还没有响应的时候崩溃了，那么在他重新启动之后就会再次收到同样的请求。Raft 的 RPCs 都是幂等的，所以这样重试不会造成任何问题。例如一个跟随者如果收到附加日志请求但是他已经包含了这一日志，那么他就会直接忽略这个新的请求。\r\n\r\n### 5.6 时间和可用性\r\n\r\nRaft 的要求之一就是安全性不能依赖时间：整个系统不能因为某些事件运行的比预期快一点或者慢一点就产生了错误的结果。但是，可用性（系统可以及时的响应客户端）不可避免的要依赖于时间。例如，如果消息交换在服务器崩溃时花费更多的时间，候选人将不会等待太长的时间来赢得选举；没有一个稳定的领导人，Raft 将无法工作。\r\n\r\n领导人选举是 Raft 中对时间要求最为关键的方面。Raft 可以选举并维持一个稳定的领导人,只要系统满足下面的时间要求：\r\n\r\n\u003e 广播时间（broadcastTime）  \u003c\u003c  选举超时时间（electionTimeout） \u003c\u003c  平均故障间隔时间（MTBF）\r\n\r\n在这个不等式中，广播时间指的是从一个服务器并行的发送 RPCs 给集群中的其他服务器并接收响应的平均时间；选举超时时间就是在 5.2 节中介绍的选举的超时时间限制；然后平均故障间隔时间就是对于一台服务器而言，两次故障之间的平均时间。广播时间必须比选举超时时间小一个量级，这样领导人才能够发送稳定的心跳消息来阻止跟随者开始进入选举状态；通过随机化选举超时时间的方法，这个不等式也使得选票瓜分的情况变得不可能。选举超时时间应该要比平均故障间隔时间小上几个数量级，这样整个系统才能稳定的运行。当领导人崩溃后，整个系统会大约相当于选举超时的时间里不可用；我们希望这种情况在整个系统的运行中很少出现。\r\n\r\n广播时间和平均故障间隔时间是由系统决定的，但是选举超时时间是我们自己选择的。Raft 的 RPCs 需要接收方将信息持久化的保存到稳定存储中去，所以广播时间大约是 0.5 毫秒到 20 毫秒，取决于存储的技术。因此，选举超时时间可能需要在 10 毫秒到 500 毫秒之间。大多数的服务器的平均故障间隔时间都在几个月甚至更长，很容易满足时间的需求。\r\n\r\n## 6 集群成员变化\r\n\r\n到目前为止，我们都假设集群的配置（加入到一致性算法的服务器集合）是固定不变的。但是在实践中，偶尔是会改变集群的配置的，例如替换那些宕机的机器或者改变复制级别。尽管可以通过暂停整个集群，更新所有配置，然后重启整个集群的方式来实现，但是在更改的时候集群会不可用。另外，如果存在手工操作步骤，那么就会有操作失误的风险。为了避免这样的问题，我们决定自动化配置改变并且将其纳入到 Raft 一致性算法中来。\r\n\r\n为了让配置修改机制能够安全，那么在转换的过程中不能够存在任何时间点使得两个领导人同时被选举成功在同一个任期里。不幸的是，任何服务器直接从旧的配置直接转换到新的配置的方案都是不安全的。一次性自动的转换所有服务器是不可能的，所以在转换期间整个集群存在划分成两个独立的大多数群体的可能性（见图 10）。\r\n\r\n![图 10](https://dn-0x01-io.qbox.me/raft-图10.png)\r\n\r\n\u003e 图 10：直接从一种配置转到新的配置是十分不安全的，因为各个机器可能在任何的时候进行转换。在这个例子中，集群配额从 3 台机器变成了 5 台。不幸的是，存在这样的一个时间点，两个不同的领导人在同一个任期里都可以被选举成功。一个是通过旧的配置，一个通过新的配置。\r\n\r\n为了保证安全性，配置更改必须使用两阶段方法。目前有很多种两阶段的实现。例如，有些系统在第一阶段停掉旧的配置所以集群就不能处理客户端请求；然后在第二阶段在启用新的配置。在 Raft 中，集群先切换到一个过渡的配置，我们称之为共同一致；一旦共同一致已经被提交了，那么系统就切换到新的配置上。共同一致是老配置和新配置的结合：\r\n\r\n* 日志条目被复制给集群中新、老配置的所有服务器。\r\n* 新、旧配置的服务器都可以成为领导人。\r\n* 达成一致（针对选举和提交）需要分别在两种配置上获得大多数的支持。\r\n\r\n共同一致允许独立的服务器在不影响安全性的前提下，在不同的时间进行配置转换过程。此外，共同一致可以让集群在配置转换的过程人依然响应服务器请求。\r\n\r\n集群配置在复制日志中以特殊的日志条目来存储和通信；图 11 展示了配置转换的过程。当一个领导人接收到一个改变配置从 C-old 到 C-new 的请求，他会为了共同一致存储配置（图中的 C-old,new），以前面描述的日志条目和副本的形式。一旦一个服务器将新的配置日志条目增加到它的日志中，他就会用这个配置来做出未来所有的决定（服务器总是使用最新的配置，无论他是否已经被提交）。这意味着领导人要使用  C-old,new 的规则来决定日志条目 C-old,new 什么时候需要被提交。如果领导人崩溃了，被选出来的新领导人可能是使用 C-old 配置也可能是 C-old,new 配置，这取决于赢得选举的候选人是否已经接收到了 C-old,new 配置。在任何情况下， C-new 配置在这一时期都不会单方面的做出决定。\r\n\r\n一旦 C-old,new 被提交，那么无论是 C-old 还是 C-new，在没有经过他人批准的情况下都不可能做出决定，并且领导人完全特性保证了只有拥有 C-old,new 日志条目的服务器才有可能被选举为领导人。这个时候，领导人创建一条关于 C-new 配置的日志条目并复制给集群就是安全的了。再者，每个服务器在见到新的配置的时候就会立即生效。当新的配置在 C-new 的规则下被提交，旧的配置就变得无关紧要，同时不使用新的配置的服务器就可以被关闭了。如图 11，C-old 和 C-new 没有任何机会同时做出单方面的决定；这保证了安全性。\r\n\r\n![图 11](https://dn-0x01-io.qbox.me/raft-图11.png)\r\n\r\n\u003e 图 11：一个配置切换的时间线。虚线表示已经被创建但是还没有被提交的条目，实线表示最后被提交的日志条目。领导人首先创建了 C-old,new 的配置条目在自己的日志中，并提交到 C-old,new 中（C-old 的大多数和  C-new 的大多数）。然后他创建 C-new 条目并提交到 C-new 中的大多数。这样就不存在  C-new 和 C-old 可以同时做出决定的时间点。\r\n\r\n在关于重新配置还有三个问题需要提出。第一个问题是，新的服务器可能初始化没有存储任何的日志条目。当这些服务器以这种状态加入到集群中，那么他们需要一段时间来更新追赶，这时还不能提交新的日志条目。为了避免这种可用性的间隔时间，Raft 在配置更新的时候使用了一种额外的阶段，在这个阶段，新的服务器以没有投票权身份加入到集群中来（领导人复制日志给他们，但是不考虑他们是大多数）。一旦新的服务器追赶上了集群中的其他机器，重新配置可以像上面描述的一样处理。\r\n\r\n第二个问题是，集群的领导人可能不是新配置的一员。在这种情况下，领导人就会在提交了 C-new 日志之后退位（回到跟随者状态）。这意味着有这样的一段时间，领导人管理着集群，但是不包括他自己；他复制日志但是不把他自己算作是大多数之一。当 C-new 被提交时，会发生领导人过渡，因为这时是最早新的配置可以独立工作的时间点（将总是能够在 C-new 配置下选出新的领导人）。在此之前，可能只能从 C-old 中选出领导人。\r\n\r\n第三个问题是，移除不在 C-new 中的服务器可能会扰乱集群。这些服务器将不会再接收到心跳，所以当选举超时，他们就会进行新的选举过程。他们会发送拥有新的任期号的请求投票 RPCs，这样会导致当前的领导人回退成跟随者状态。新的领导人最终会被选出来，但是被移除的服务器将会再次超时，然后这个过程会再次重复，导致整体可用性大幅降低。\r\n\r\n为了避免这个问题，当服务器确认当前领导人存在时，服务器会忽略请求投票 RPCs。特别的，当服务器在当前最小选举超时时间内收到一个请求投票 RPC，他不会更新当前的任期号或者投出选票。这不会影响正常的选举，每个服务器在开始一次选举之前，至少等待一个最小选举超时时间。然而，这有利于避免被移除的服务器扰乱：如果领导人能够发送心跳给集群，那么他就不会被更大的任期号废黜。\r\n\r\n## 7 日志压缩\r\n\r\nRaft 的日志在正常操作中不断的增长，但是在实际的系统中，日志不能无限制的增长。随着日志不断增长，他会占用越来越多的空间，花费越来越多的时间来重置。如果没有一定的机制去清除日志里积累的陈旧的信息，那么会带来可用性问题。\r\n\r\n快照是最简单的压缩方法。在快照系统中，整个系统的状态都以快照的形式写入到稳定的持久化存储中，然后到那个时间点之前的日志全部丢弃。快照技术被使用在 Chubby 和 ZooKeeper 中，接下来的章节会介绍 Raft 中的快照技术。\r\n\r\n增量压缩的方法，例如日志清理或者日志结构合并树，都是可行的。这些方法每次只对一小部分数据进行操作，这样就分散了压缩的负载压力。首先，他们先选择一个已经积累的大量已经被删除或者被覆盖对象的区域，然后重写那个区域还活跃的对象，之后释放那个区域。和简单操作整个数据集合的快照相比，需要增加复杂的机制来实现。状态机可以实现 LSM tree 使用和快照相同的接口，但是日志清除方法就需要修改 Raft 了。\r\n\r\n![图 12](https://dn-0x01-io.qbox.me/raft-图12.png)\r\n\r\n\u003e 图 12：一个服务器用新的快照替换了从 1 到 5 的条目，快照值存储了当前的状态。快照中包含了最后的索引位置和任期号。\r\n\r\n图 12 展示了 Raft 中快照的基础思想。每个服务器独立的创建快照，只包括已经被提交的日志。主要的工作包括将状态机的状态写入到快照中。Raft 也包含一些少量的元数据到快照中：**最后被包含索引**指的是被快照取代的最后的条目在日志中的索引值（状态机最后应用的日志），**最后被包含的任期**指的是该条目的任期号。保留这些数据是为了支持快照前的第一个条目的附加日志请求时的一致性检查，因为这个条目需要最后的索引值和任期号。为了支持集群成员更新（第 6 节），快照中也将最后的一次配置作为最后一个条目存下来。一旦服务器完成一次快照，他就可以删除最后索引位置之前的所有日志和快照了。\r\n\r\n尽管通常服务器都是独立的创建快照，但是领导人必须偶尔的发送快照给一些落后的跟随者。这通常发生在当领导人已经丢弃了下一条需要发送给跟随者的日志条目的时候。幸运的是这种情况不是常规操作：一个与领导人保持同步的跟随者通常都会有这个条目。然而一个运行非常缓慢的跟随者或者新加入集群的服务器（第 6 节）将不会有这个条目。这时让这个跟随者更新到最新的状态的方式就是通过网络把快照发送给他们。\r\n\r\n**安装快照 RPC**：\r\n\r\n在领导人发送快照给跟随者时使用到。领导人总是按顺序发送。\r\n\r\n| 参数 | 解释 |\r\n|----|----|\r\n| term | 领导人的任期号 |\r\n| leaderId | 领导人的 Id，以便于跟随者重定向请求 |\r\n| lastIncludedIndex | 快照中包含的最后日志条目的索引值 |\r\n| lastIncludedTerm | 快照中包含的最后日志条目的任期号 |\r\n| offset | 分块在快照中的偏移量 |\r\n| data[] | 原始数据 |\r\n| done | 如果这是最后一个分块则为 true |\r\n\r\n| 结果 | 解释 |\r\n|----|----|\r\n| term | 当前任期号，便于领导人更新自己 |\r\n\r\n**接收者实现**：\r\n\r\n1. 如果`term \u003c currentTerm`就立即回复\r\n2. 如果是第一个分块（offset 为 0）就创建一个新的快照\r\n3. 在指定偏移量写入数据\r\n4. 如果 done 是 false，则继续等待更多的数据\r\n5. 保存快照文件，丢弃索引值小于快照的日志\r\n6. 如果现存的日志拥有相同的最后任期号和索引值，则后面的数据继续保持\r\n7. 丢弃整个日志\r\n8. 使用快照重置状态机\r\n\r\n\u003e 图 13：一个关于安装快照的简要概述。为了便于传输，快照都是被分成分块的；每个分块都给了跟随者生命的迹象，所以跟随者可以重置选举超时计时器。\r\n\r\n\r\n在这种情况下领导人使用一种叫做安装快照的新的 RPC 来发送快照给太落后的跟随者；见图 13。当跟随者通过这种  RPC 接收到快照时，他必须自己决定对于已经存在的日志该如何处理。通常快照会包含没有在接收者日志中存在的信息。在这种情况下，跟随者直接丢弃他所有的日志；这些会被快照所取代，但是可能会和没有提交的日志产生冲突。如果接收到的快照是自己日志的前面部分（由于网络重传或者错误），那么被快照包含的条目将会被全部删除，但是快照之后的条目必须正确和保留。\r\n\r\n这种快照的方式背离了 Raft 的强领导人原则，因为跟随者可以在不知道领导人情况下创建快照。但是我们认为这种背离是值得的。领导人的存在，是为了解决在达成一致性的时候的冲突，但是在创建快照的时候，一致性已经达成，这时不存在冲突了，所以没有领导人也是可以的。数据依然是从领导人传给跟随者，只是跟随者可以重新组织他们的数据了。\r\n\r\n我们考虑过一种替代的基于领导人的快照方案，即只有领导人创建快照，然后发送给所有的跟随者。但是这样做有两个缺点。第一，发送快照会浪费网络带宽并且延缓了快照处理的时间。每个跟随者都已经拥有了所有产生快照需要的信息，而且很显然，自己从本地的状态中创建快照比通过网络接收别人发来的要经济。第二，领导人的实现会更加复杂。例如，领导人需要发送快照的同时并行的将新的日志条目发送给跟随者，这样才不会阻塞新的客户端请求。\r\n\r\n还有两个问题影响了快照的性能。首先，服务器必须决定什么时候应该创建快照。如果快照创建的过于频繁，那么就会浪费大量的磁盘带宽和其他资源；如果创建快照频率太低，他就要承受耗尽存储容量的风险，同时也增加了从日志重建的时间。一个简单的策略就是当日志大小达到一个固定大小的时候就创建一次快照。如果这个阈值设置的显著大于期望的快照的大小，那么快照对磁盘压力的影响就会很小了。\r\n\r\n第二个影响性能的问题就是写入快照需要花费显著的一段时间，并且我们还不希望影响到正常操作。解决方案是通过写时复制的技术，这样新的更新就可以被接收而不影响到快照。例如，具有函数式数据结构的状态机天然支持这样的功能。另外，操作系统的写时复制技术的支持（如 Linux 上的 fork）可以被用来创建完整的状态机的内存快照（我们的实现就是这样的）。\r\n\r\n## 8 客户端交互\r\n\r\n这一节将介绍客户端是如何和 Raft 进行交互的，包括客户端如何发现领导人和 Raft 是如何支持线性化语义的。这些问题对于所有基于一致性的系统都存在，并且 Raft 的解决方案和其他的也差不多。\r\n\r\nRaft 中的客户端发送所有请求给领导人。当客户端启动的时候，他会随机挑选一个服务器进行通信。如果客户端第一次挑选的服务器不是领导人，那么那个服务器会拒绝客户端的请求并且提供他最近接收到的领导人的信息（附加条目请求包含了领导人的网络地址）。如果领导人已经崩溃了，那么客户端的请求就会超时；客户端之后会再次重试随机挑选服务器的过程。\r\n\r\n我们 Raft 的目标是要实现线性化语义（每一次操作立即执行，只执行一次，在他调用和收到回复之间）。但是，如上述，Raft 是可以执行同一条命令多次的：例如，如果领导人在提交了这条日志之后，但是在响应客户端之前崩溃了，那么客户端会和新的领导人重试这条指令，导致这条命令就被再次执行了。解决方案就是客户端对于每一条指令都赋予一个唯一的序列号。然后，状态机跟踪每条指令最新的序列号和相应的响应。如果接收到一条指令，它的序列号已经被执行了，那么就立即返回结果，而不重新执行指令。\r\n\r\n只读的操作可以直接处理而不需要记录日志。但是，在不增加任何限制的情况下，这么做可能会冒着返回脏数据的风险，因为领导人响应客户端请求时可能已经被新的领导人作废了，但是他还不知道。线性化的读操作必须不能返回脏数据，Raft 需要使用两个额外的措施在不使用日志的情况下保证这一点。首先，领导人必须有关于被提交日志的最新信息。领导人完全特性保证了领导人一定拥有所有已经被提交的日志条目，但是在他任期开始的时候，他可能不知道那些是已经被提交的。为了知道这些信息，他需要在他的任期里提交一条日志条目。Raft 中通过领导人在任期开始的时候提交一个空白的没有任何操作的日志条目到日志中去来实现。第二，领导人在处理只读的请求之前必须检查自己是否已经被废黜了（他自己的信息已经变脏了如果一个更新的领导人被选举出来）。Raft 中通过让领导人在响应只读请求之前，先和集群中的大多数节点交换一次心跳信息来处理这个问题。可选的，领导人可以依赖心跳机制来实现一种租约的机制，但是这种方法依赖时间来保证安全性（假设时间误差是有界的）。\r\n\r\n## 9 算法实现和评估\r\n\r\n我们已经为 RAMCloud 实现了 Raft 算法作为存储配置信息的复制状态机的一部分，并且帮助 RAMCloud 协调故障转移。这个 Raft 实现包含大约 2000 行 C++ 代码，其中不包括测试、注释和空行。这些代码是开源的。同时也有大约 25 个其他独立的第三方的基于这篇论文草稿的开源实现，针对不同的开发场景。同时，很多公司已经部署了基于 Raft 的系统。\r\n\r\n这一节会从三个方面来评估 Raft 算法：可理解性、正确性和性能。\r\n\r\n### 9.1 可理解性\r\n\r\n为了和 Paxos 比较 Raft 算法的可理解能力，我们针对高层次的本科生和研究生，在斯坦福大学的高级操作系统课程和加州大学伯克利分校的分布式计算课程上，进行了一次学习的实验。我们分别拍了针对 Raft 和 Paxos 的视频课程，并准备了相应的小测验。Raft 的视频讲课覆盖了这篇论文的所有内容除了日志压缩；Paxos 讲课包含了足够的资料来创建一个等价的复制状态机，包括单决策 Paxos，多决策 Paxos，重新配置和一些实际系统需要的性能优化（例如领导人选举）。小测验测试一些对算法的基本理解和解释一些边角的示例。每个学生都是看完第一个视频，回答相应的测试，再看第二个视频，回答相应的测试。大约有一半的学生先进行 Paxos 部分，然后另一半先进行 Raft 部分，这是为了说明两者独立的区别从第一个算法处学来的经验。我们计算参加人员的每一个小测验的得分来看参与者是否在 Raft 算法上更加容易理解。\r\n\r\n我们尽可能的使得 Paxos 和 Raft 的比较更加公平。这个实验偏爱 Paxos 表现在两个方面：43 个参加者中有 15 个人在之前有一些  Paxos 的经验，并且 Paxos 的视频要长 14%。如表格 1 总结的那样，我们采取了一些措施来减轻这种潜在的偏见。我们所有的材料都可供审查。\r\n\r\n| 关心 | 缓和偏见采取的手段 | 可供查看的材料 |\r\n|----|----|----|\r\n| 相同的讲课质量 | 两者使用同一个讲师。Paxos 使用的是现在很多大学里经常使用的。Paxos 会长 14%。 | 视频 |\r\n| 相同的测验难度 | 问题以难度分组，在两个测验里成对出现。| 小测验 |\r\n| 公平评分 | 使用红字标题。随机顺序打分，两个测验交替进行。 | 红字标题 |\r\n\r\n\u003e 表 1：考虑到可能会存在的偏见，对于每种情况的解决方法，和相应的材料。\r\n\r\n参加者平均在 Raft 的测验中比 Paxos 高 4.9 分（总分 60，那么 Raft 的平均得分是 25.7，而 Paxos 是 20.8）；图 14 展示了每个参与者的得分。一对 t -测试表明，拥有 95% 的可信度，真实的 Raft 分数分布至少比 Paxos 高 2.5 分。\r\n\r\n![图 14](https://camo.githubusercontent.com/6b13422da7af59045117fc263afbd938ecce8574/68747470733a2f2f646e2d307830312d696f2e71626f782e6d652f726166742d25453525394225424531342e706e67)\r\n\r\n\u003e 图 14：一个散点图表示了 43 个学生在 Paxos 和 Raft 的小测验中的成绩。在对角线之上的点表示在 Raft 获得了更高分数的学生。\r\n\r\n我们也建立了一个线性回归模型来预测一个新的学生的测验成绩，基于以下三个因素：他们使用的是哪个小测验，之前对 Paxos 的经验，和学习算法的顺序。模型显示，对小测验的选择会产生 12.5 分的差别在对  Raft 的好感度上。这显著的高于之前的 4.9 分，因为很多学生在之前都已经有了对于   Paxos 的经验，这相当明显的帮助 Paxos，对 Raft 就没什么太大影响了。但是奇怪的是，模型预测对于先进性 Paxos 小测验的人而言，Raft 的小测验得分会比 Paxos 低 6.3 分；我们不知道为什么，但这在统计学上是这样的。\r\n\r\n我们同时也在测验之后调查了参与者，他们认为哪个算法更加容易实现和解释；这个的结果在图 15 上。压倒性的结果表明 Raft 算法更加容易实现和解释（41 人中的 33个）。但是，这种自己报告的结果不如参与者的成绩更加可信，并且参与者可能因为我们的 Raft 更加易于理解的假说而产生偏见。\r\n\r\n![图 15](https://camo.githubusercontent.com/7a13f44249bc5dc267259275999d89646ac53584/68747470733a2f2f646e2d307830312d696f2e71626f782e6d652f726166742d25453525394225424531352e706e67)\r\n\r\n\u003e 图 15：通过一个 5 分制的问题，参与者（左边）被问哪个算法他们觉得在一个高效正确的系统里更容易实现，右边被问哪个更容易向学生解释。\r\n\r\n关于 Raft 用户学习有一个更加详细的讨论。\r\n\r\n### 9.2 正确性\r\n\r\n在第 5 节，我们已经进行了一个正式的说明，和对一致性机制的安全性证明。这个正式说明让图 2 中的信息非常清晰通过 TLA+ 说明语言。大约 400 行说明充当了证明的主题。同时对于任何想实现的人也是十分有用的。我们非常机械的证明了日志完全特性通过 TLA 证明系统。然而，这个证明依赖的约束前提还没有被机械证明（例如，我们还没有证明这个说明中的类型安全）。而且，我们已经写了一个非正式的证明关于状态机安全性质是完备的，并且是相当清晰的（大约 3500 个词）。\r\n\r\n### 9.3 性能\r\n\r\nRaft 和其他一致性算法例如 Paxos 有着差不多的性能。在性能方面，最重要的关注点是，当领导人被选举成功时，什么时候复制新的日志条目。Raft 通过很少数量的消息包（一轮从领导人到集群大多数机器的消息）就达成了这个目的。同时，进一步提升 Raft 的性能也是可行的。例如，很容易通过支持批量操作和管道操作来提高吞吐量和降低延迟。对于其他一致性算法已经提出过很多性能优化方案；其中有很多也可以应用到 Raft 中来，但是我们暂时把这个问题放到未来的工作中去。\r\n\r\n我们使用我们自己的 Raft 实现来衡量 Raft 领导人选举的性能并且回答两个问题。首先，领导人选举的过程收敛是否快速？第二，在领导人宕机之后，最小的系统宕机时间是多久？\r\n\r\n![图 16](https://camo.githubusercontent.com/8b7e3951033ea5070d976633961638cab2d902b5/68747470733a2f2f646e2d307830312d696f2e71626f782e6d652f726166742d25453525394225424531362e706e67)\r\n\r\n\u003e 图 16：发现并替换一个已经崩溃的领导人的时间。上面的图考察了在选举超时时间上的随机化程度，下面的图考察了最小超时时间。每条线代表了 1000 次实验（除了 150-150 毫秒只试了 100 次），和相应的确定的选举超时时间。例如，150-155 毫秒意思是，选举超时时间从这个区间范围内随机选择并确定下来。这个实验在一个拥有 5 个节点的集群上进行，其广播时延大约是 15 毫秒。对于 9 个节点的集群，结果也差不多。\r\n\r\n为了衡量领导人选举，我们反复的使一个拥有五个节点的服务器集群的领导人宕机，并计算需要多久才能发现领导人已经宕机并选出一个新的领导人（见图 16）。为了构建一个最坏的场景，在每一的尝试里，服务器都有不同长度的日志，意味着有些候选人是没有成为领导人的资格的。另外，为了促成选票瓜分的情况，我们的测试脚本在终止领导人之前同步的发送了一次心跳广播（这大约和领导人在崩溃前复制一个新的日志给其他机器很像）。领导人均匀的随机的在心跳间隔里宕机，也就是最小选举超时时间的一半。因此，最小宕机时间大约就是最小选举超时时间的一半。\r\n\r\n图 16 上面的图表表明，只需要在选举超时时间上使用很少的随机化就可以大大避免选票被瓜分的情况。在没有随机化的情况下，在我们的测试里，选举过程往往都需要花费超过 10 秒钟由于太多的选票瓜分的情况。仅仅增加 5 毫秒的随机化时间，就大大的改善了选举过程，现在平均的宕机时间只有 287 毫秒。增加更多的随机化时间可以大大改善最坏情况：通过增加 50 毫秒的随机化时间，最坏的完成情况（1000 次尝试）只要 513 毫秒。\r\n\r\n图 16 中下面的图显示，通过减少选举超时时间可以减少系统的宕机时间。在选举超时时间为 12-24 毫秒的情况下，只需要平均 35 毫秒就可以选举出新的领导人（最长的一次花费了 152 毫秒）。然而，进一步降低选举超时时间的话就会违反 Raft 的时间不等式需求：在选举新领导人之前，领导人就很难发送完心跳包。这会导致没有意义的领导人改变并降低了系统整体的可用性。我们建议使用更为保守的选举超时时间，比如 150-300 毫秒；这样的时间不大可能导致没有意义的领导人改变，而且依然提供不错的可用性。\r\n\r\n## 10 相关工作\r\n\r\n已经有很多关于一致性算法的工作被发表出来，其中很多都可以归到下面的类别中：\r\n\r\n* Lamport 关于 Paxos 的原始描述，和尝试描述的更清晰。\r\n* 关于 Paxos 的更详尽的描述，补充遗漏的细节并修改算法，使得可以提供更加容易的实现基础。\r\n* 实现一致性算法的系统，例如 Chubby，ZooKeeper 和 Spanner。对于 Chubby 和 Spanner 的算法并没有公开发表其技术细节，尽管他们都声称是基于 Paxos 的。ZooKeeper 的算法细节已经发表，但是和 Paxos 着实有着很大的差别。\r\n* Paxos 可以应用的性能优化。\r\n* Oki 和 Liskov 的 Viewstamped Replication（VR），一种和 Paxos 差不多的替代算法。原始的算法描述和分布式传输协议耦合在了一起，但是核心的一致性算法在最近的更新里被分离了出来。VR 使用了一种基于领导人的方法，和 Raft 有很多相似之处。\r\n\r\nRaft 和 Paxos 最大的不同之处就在于 Raft 的强领导特性：Raft 使用领导人选举作为一致性协议里必不可少的部分，并且将尽可能多的功能集中到了领导人身上。这样就可以使得算法更加容易理解。例如，在 Paxos 中，领导人选举和基本的一致性协议是正交的：领导人选举仅仅是性能优化的手段，而且不是一致性所必须要求的。但是，这样就增加了多余的机制：Paxos 同时包含了针对基本一致性要求的两阶段提交协议和针对领导人选举的独立的机制。相比较而言，Raft 就直接将领导人选举纳入到一致性算法中，并作为两阶段一致性的第一步。这样就减少了很多机制。\r\n\r\n像 Raft 一样，VR 和 ZooKeeper 也是基于领导人的，因此他们也拥有一些 Raft 的优点。但是，Raft 比 VR 和 ZooKeeper 拥有更少的机制因为 Raft 尽可能的减少了非领导人的功能。例如，Raft 中日志条目都遵循着从领导人发送给其他人这一个方向：附加条目 RPC 是向外发送的。在 VR 中，日志条目的流动是双向的（领导人可以在选举过程中接收日志）；这就导致了额外的机制和复杂性。根据 ZooKeeper 公开的资料看，它的日志条目也是双向传输的，但是它的实现更像 Raft。\r\n\r\n和上述我们提及的其他基于一致性的日志复制算法中，Raft 的消息类型更少。例如，我们数了一下 VR 和 ZooKeeper 使用的用来基本一致性需要和成员改变的消息数（排除了日志压缩和客户端交互，因为这些都比较独立且和算法关系不大）。VR 和 ZooKeeper 都分别定义了 10 中不同的消息类型，相对的，Raft 只有 4 中消息类型（两种 RPC 请求和对应的响应）。Raft 的消息都稍微比其他算法的要信息量大，但是都很简单。另外，VR 和 ZooKeeper 都在领导人改变时传输了整个日志；所以为了能够实践中使用，额外的消息类型就很必要了。\r\n\r\nRaft 的强领导人模型简化了整个算法，但是同时也排斥了一些性能优化的方法。例如，平等主义 Paxos （EPaxos）在某些没有领导人的情况下可以达到很高的性能。平等主义 Paxos 充分发挥了在状态机指令中的交换性。任何服务器都可以在一轮通信下就提交指令，除非其他指令同时被提出了。然而，如果指令都是并发的被提出，并且互相之间不通信沟通，那么 EPaxos 就需要额外的一轮通信。因为任何服务器都可以提交指令，所以 EPaxos 在服务器之间的负载均衡做的很好，并且很容易在 WAN 网络环境下获得很低的延迟。但是，他在 Paxos 上增加了非常明显的复杂性。\r\n\r\n一些集群成员变换的方法已经被提出或者在其他的工作中被实现，包括 Lamport 的原始的讨论，VR 和 SMART。我们选择使用共同一致的方法因为他对一致性协议的其他部分影响很小，这样我们只需要很少的一些机制就可以实现成员变换。Lamport 的基于 α 的方法之所以没有被 Raft 选择是因为它假设在没有领导人的情况下也可以达到一致性。和 VR 和 SMART 相比较，Raft 的重新配置算法可以在不限制正常请求处理的情况下进行；相比较的，VR 需要停止所有的处理过程，SMART 引入了一个和 α 类似的方法，限制了请求处理的数量。Raft 的方法同时也需要更少的额外机制来实现，和 VR、SMART 比较而言。\r\n\r\n## 11 结论\r\n\r\n算法的设计通常会把正确性，效率或者简洁作为主要的目标。尽管这些都是很有意义的目标，但是我们相信，可理解性也是一样的重要。在开发者把算法应用到实际的系统中之前，这些目标没有一个会被实现，这些都会必然的偏离发表时的形式。除非开发人员对这个算法有着很深的理解并且有着直观的感觉，否则将会对他们而言很难在实现的时候保持原有期望的特性。\r\n\r\n在这篇论文中，我们尝试解决分布式一致性问题，但是一个广为接受但是十分令人费解的算法 Paxos 已经困扰了无数学生和开发者很多年了。我们创造了一种新的算法 Raft，显而易见的比 Paxos 要容易理解。我们同时也相信，Raft 也可以为实际的实现提供坚实的基础。把可理解性作为设计的目标改变了我们设计 Raft 的方式；这个过程是我们发现我们最终很少有技术上的重复，例如问题分解和简化状态空间。这些技术不仅提升了 Raft 的可理解性，同时也使我们坚信其正确性。\r\n\r\n## 12 感谢\r\n\r\n这项研究必须感谢以下人员的支持：Ali Ghodsi，David Mazie`res，和伯克利 CS 294-91 课程、斯坦福 CS 240 课程的学生。Scott Klemmer 帮我们设计了用户调查，Nelson Ray 建议我们进行统计学的分析。在用户调查时使用的关于 Paxos 的幻灯片很大一部分是从 Lorenzo Alvisi 的幻灯片上借鉴过来的。特别的，非常感谢 DavidMazieres 和 Ezra Hoch，他们找到了 Raft 中一些难以发现的漏洞。许多人提供了关于这篇论文十分有用的反馈和用户调查材料，包括 Ed Bugnion，Michael Chan，Hugues Evrard，Daniel Giffin，Arjun Gopalan，Jon Howell，Vimalkumar Jeyakumar，Ankita Kejriwal，Aleksandar Kracun，Amit Levy，Joel Martin，Satoshi Matsushita，Oleg Pesok，David Ramos，Robbert van Renesse，Mendel Rosenblum，Nicolas Schiper，Deian Stefan，Andrew Stone，Ryan Stutsman，David Terei，Stephen Yang，Matei Zaharia 以及 24 位匿名的会议审查人员（可能有重复），并且特别感谢我们的领导人 Eddie Kohler。Werner Vogels 发了一条早期草稿链接的推特，给 Raft 带来了极大的关注。我们的工作由 Gigascale 系统研究中心和 Multiscale 系统研究中心给予支持，这两个研究中心由关注中心研究程序资金支持，一个是半导体研究公司的程序，由 STARnet 支持，一个半导体研究公司的程序由 MARCO 和 DARPA 支持，在国家科学基金会的 0963859 号批准，并且获得了来自 Facebook，Google，Mellanox，NEC，NetApp，SAP 和 Samsung 的支持。Diego Ongaro 由 Junglee 公司，斯坦福的毕业团体支持。\r\n\r\n## 参考\r\n\r\n略","cover":"https://images.pexels.com/photos/821754/pexels-photo-821754.jpeg?auto=compress\u0026cs=tinysrgb\u0026h=350","link":"寻找一种易于理解的一致性算法raft算法.html","preview":"\u003cp\u003eRaft 是一种为了管理复制日志的一致性算法。它提供了和 Paxos 算法相同的功能和性能，但是它的算法结构和 Paxos 不同，使得 Raft 算法更加容易理解并且更容易构建实际的系统。……从一个用户研究的结果可以证明，对于学生而言，Raft 算法比 Paxos 算法更加容易学习。Raft 算法还包括一个新的机制来允许集群成员的动态改变，它利用重叠的大多数来保证安全性。\u003c/p\u003e\n","title":"寻找一种易于理解的一致性算法Raft算法"},{"content":"---\r\n\r\n\r\n\u003e转自 [陈皓 酷 壳 – CoolShell](https://coolshell.cn/articles/18094.html)\r\n\r\n以下是原文：\r\n\r\n![](//www.igtx.top/images/enable-https-banner.png)\r\n\r\n\r\n今天，我把CoolShell变成https的安全访问了。我承认这件事有点晚了，因为之前的HTTP的问题也有网友告诉我，被国内的电信运营商在访问我的网站时加入了一些弹窗广告。另外，HTTP的网站在搜索引擎中的rank会更低。所以，这事早就应该干了。现在用HTTP访问CoolShell会被得到一个 301 的HTTPS的跳转。下面我分享一下启用HTTPS的过程。\r\n\r\n我用的是 \u003ca href=\"https://letsencrypt.org\" target=\"_blank\" rel=\"noopener\"\u003eLet’s Encrypt\u003c/a\u003e这个免费的解决方案。Let’s Encrypt 是一个于2015年推出的数字证书认证机构，将通过旨在消除当前手动创建和安装证书的复杂过程的自动化流程，为安全网站提供免费的SSL/TLS证书。这是由\u003ca href=\"https://letsencrypt.org/isrg/\" target=\"_blank\" rel=\"noopener\"\u003e互联网安全研究小组\u003c/a\u003e（ISRG – Internet Security Research Group，一个公益组织）提供的服务。主要赞助商包括\u003ca title=\"电子前哨基金会\" href=\"https://www.eff.org\" target=\"_blank\" rel=\"noopener\"\u003e电子前哨基金会\u003c/a\u003e，\u003ca class=\"mw-redirect\" title=\"Mozilla基金会\" href=\"https://www.mozilla.org/foundation/\" target=\"_blank\" rel=\"noopener\"\u003eMozilla基金会\u003c/a\u003e，\u003ca title=\"Akamai\" href=\"https://www.akamai.com/\" target=\"_blank\" rel=\"noopener\"\u003eAkamai\u003c/a\u003e以及Cisco等公司（\u003ca href=\"https://letsencrypt.org/sponsors/\" target=\"_blank\" rel=\"noopener\"\u003e赞助商列表\u003c/a\u003e）。\r\n\r\n2015年6月，Let’s Encrypt得到了一个存储在硬件安全模块中的离线的RSA根证书。这个由IdenTrust证书签发机构交叉签名的根证书被用于签署两个证书。其中一个就是用于签发请求的证书，另一个则是保存在本地的证书，这个证书用于在上一个证书出问题时作备份证书之用。因为IdenTrust的CA根证书目前已被预置于主流浏览器中，所以Let’s Encrypt签发的证书可以从项目开始就被识别并接受，甚至当用户的浏览器中没有信任ISRG的根证书时也可以。\r\n\r\n以上介绍文字来自 Wikipedia 的 \u003ca href=\"https://zh.wikipedia.org/wiki/Let%27s_Encrypt\" target=\"_blank\" rel=\"noopener\"\u003eLet’s Encrypt 词条\u003c/a\u003e。\r\n\r\n为你的网站来安装一个证书十分简单，只需要使用电子子前哨基金会EFF的 \u003ca href=\"https://certbot.eff.org\" target=\"_blank\" rel=\"noopener\"\u003eCertbot\u003c/a\u003e，就可以完成。\r\n\u003cp style=\"padding-left: 30px;\"\u003e1）首先，打开\u0026nbsp;\u003ca href=\"https://certbot.eff.org\" target=\"_blank\" rel=\"noopener\"\u003ehttps://certbot.eff.org\u003c/a\u003e 网页。\r\n\u003cp style=\"padding-left: 30px;\"\u003e2）在那个机器上图标下面，你需要选择一下你用的 Web 接入软件 和你的 操作系统。比如，我选的，\u003ccode\u003enginx\u003c/code\u003e\u0026nbsp;和 \u003ccode\u003eUbuntu 14.04\u003c/code\u003e\r\n\u003cp style=\"padding-left: 30px;\"\u003e3）然后就会跳转到一个安装教程网页。你就照着做一遍就好了。\r\n以Coolshell.cn为例 – Nginx + Ubuntu\r\n首先先安装相应的环境：\r\n\r\n``` sh\r\n$ sudo apt-get update\r\n$ sudo apt-get install software-properties-common\r\n$ sudo add-apt-repository ppa:certbot/certbot\r\n$ sudo apt-get update\r\n$ sudo apt-get install python-certbot-nginx\r\n\r\n```\r\n\r\n然后，运行如下命令：\r\n\r\n```sh\r\n$ sudo certbot --nginx\r\n```\r\n\r\n\u003ccode\u003ecertbot\u003c/code\u003e 会自动检查到你的 \u003ccode\u003enginx.conf\u003c/code\u003e 下的配置，把你所有的虚拟站点都列出来，然后让你选择需要开启 https 的站点。你就简单的输入列表编号（用空格分开），然后，certbot 就帮你下载证书并更新 \u003ccode\u003enginx.conf\u003c/code\u003e 了。\r\n\r\n```sh\r\nlisten 443 ssl; # managed by Certbot\r\nssl_certificate /etc/letsencrypt/live/coolshell.cn/fullchain.pem; # managed by Certbot\r\nssl_certificate_key /etc/letsencrypt/live/coolshell.cn/privkey.pem; # managed by Certbot\r\ninclude /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot\r\n```\r\n和\r\n\r\n```sh\r\n# Redirect non-https traffic to https\r\nif ($scheme != \"https\") {\r\n  return 301 https://$host$request_uri;\r\n} # managed by Certbot\r\n```\r\n这里建议配置 http2，这要求 Nginx 版本要大于 1.9.5。HTTP2 具有更快的 HTTPS 传输性能，非常值得开启（\u003ca href=\"http://blog.httpwatch.com/2015/01/16/a-simple-performance-comparison-of-https-spdy-and-http2/\" target=\"_blank\" rel=\"noopener\"\u003e关于性能你可以看一下这篇文章\u003c/a\u003e）。需要开启HTTP/2其实很简单，只需要在 \u003ccode\u003enginx.conf\u003c/code\u003e\u0026nbsp;的 \u003ccode\u003elisten 443 ssl;\u003c/code\u003e\u0026nbsp;后面加上 \u003ccode\u003ehttp2\u003c/code\u003e\u0026nbsp;就好了。如下所示：\r\n\r\n```sh\r\nlisten 443 ssl http2; # managed by Certbot \r\nssl_certificate /etc/letsencrypt/live/coolshell.cn/fullchain.pem; # managed by Certbot \r\nssl_certificate_key /etc/letsencrypt/live/coolshell.cn/privkey.pem; # managed by Certbot \r\ninclude /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot\r\n```\r\n\r\n然后，就 \u003ccode\u003enginx -s reload\u003c/code\u003e\u0026nbsp;就好了。\r\n但是，**Let’s Encrypt 的证书90天就过期了**，所以，你还要设置上自动化的更新脚本，最容易的莫过于使用 \u003ccode\u003ecrontab\u003c/code\u003e\u0026nbsp;了。使用 \u003ccode\u003ecrontab -e\u003c/code\u003e\u0026nbsp;命令加入如下的定时作业（每个月都强制更新一下）：\r\n\r\n```sh\r\n0 0 1 * * /usr/bin/certbot renew --force-renewal\r\n5 0 1 * * /usr/sbin/service nginx restart\r\n```\r\n\r\n当然，你也可以每天凌晨1点检查一下：\r\n\r\n```sh\r\n0 1 * * * certbot renew\r\n```\r\n\r\n注：crontab 中有六个字段，其含义如下：\r\n\r\n* 第1个字段：分钟 (0-59)\r\n* 第2个字段：小时 (0-23)\r\n* 第3个字段：日期 (1-31)\r\n* 第4个字段：月份 (1-12 [12 代表 December])\r\n* 第5个字段：一周当中的某天 (0-7 [7 或 0 代表星期天])\r\n* /path/to/command – 计划执行的脚本或命令的名称\r\n\r\n**这么方便的同时，我不禁要问，如果是一些恶意的钓鱼网站也让自己的站点变成https的，这个对于一般用来说就有点难以防范了。哎……**\r\n当然，在nginx或apache上启用HTTPS后，还没有结束。因为你可能还需要修改一下你的网站，不然你的网站在浏览时会出现各种问题。\r\n**启用HTTPS后，你的网页中的所有的使用 \u003ccode\u003ehttp://\u003c/code\u003e\u0026nbsp;的方式的地方都要改成 \u003ccode\u003ehttps://\u003c/code\u003e\u0026nbsp;不然你的图片，js， css等非https的连接都会导致浏览器抱怨不安全而被block掉**。所以，你还需要修改你的网页中那些 hard code \u003ccode\u003ehttp://\u003c/code\u003e\u0026nbsp;的地方。\r\n对于我这个使用wordpress的博客系统来说，有这么几个部分需要做修改。\r\n\r\n1. 首先是 wordpress的 常规设置中的 “WordPress 地址” 和 “站点地址” 需要变更为 https 的方式。\r\n2. 然后是文章内的图片等资源的链接需要变更为 https 的方式。对此，你可以使用一个叫 “Search Regex” 插件来批量更新你历史文章里的图片或别的资源的链接。比如：把 **http://coolshell.cn** 替换成了 **https://coolshell.cn**\r\n3. 如果你像我一样启用了文章缓存（我用的是WP-SuperCache插件），你还要去设置一下 “CDN” 页面中的 “Site URL” 和 “off-site URL” 确保生成出来的静态网页内是用https做资源链接的。\r\n\r\n基本上就是这些事。希望大家都来把自己的网站更新成 https 的。\r\n\r\n嗯，12306，你什么时候按照这个教程做一下你的证书？\r\n\r\n（全文完）\r\n","cover":"","link":"如何免费的让网站启用https.html","preview":"\u003chr /\u003e\n\n\u003cblockquote\u003e\n\u003cp\u003e转自 \u003ca href=\"https://coolshell.cn/articles/18094.html\"\u003e陈皓 酷 壳 – CoolShell\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e以下是原文：\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"data:image/gif;base64,R0lGODlhGAAYAPQAAP///wAAAM7Ozvr6+uDg4LCwsOjo6I6OjsjIyJycnNjY2KioqMDAwPLy8nd3d4aGhri4uGlpaQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAkHAAAAIf4aQ3JlYXRlZCB3aXRoIGFqYXhsb2FkLmluZm8AIf8LTkVUU0NBUEUyLjADAQAAACwAAAAAGAAYAAAFriAgjiQAQWVaDgr5POSgkoTDjFE0NoQ8iw8HQZQTDQjDn4jhSABhAAOhoTqSDg7qSUQwxEaEwwFhXHhHgzOA1xshxAnfTzotGRaHglJqkJcaVEqCgyoCBQkJBQKDDXQGDYaIioyOgYSXA36XIgYMBWRzXZoKBQUMmil0lgalLSIClgBpO0g+s26nUWddXyoEDIsACq5SsTMMDIECwUdJPw0Mzsu0qHYkw72bBmozIQAh+QQJBwAAACwAAAAAGAAYAAAFsCAgjiTAMGVaDgR5HKQwqKNxIKPjjFCk0KNXC6ATKSI7oAhxWIhezwhENTCQEoeGCdWIPEgzESGxEIgGBWstEW4QCGGAIJEoxGmGt5ZkgCRQQHkGd2CESoeIIwoMBQUMP4cNeQQGDYuNj4iSb5WJnmeGng0CDGaBlIQEJziHk3sABidDAHBgagButSKvAAoyuHuUYHgCkAZqebw0AgLBQyyzNKO3byNuoSS8x8OfwIchACH5BAkHAAAALAAAAAAYABgAAAW4ICCOJIAgZVoOBJkkpDKoo5EI43GMjNPSokXCINKJCI4HcCRIQEQvqIOhGhBHhUTDhGo4diOZyFAoKEQDxra2mAEgjghOpCgz3LTBIxJ5kgwMBShACREHZ1V4Kg1rS44pBAgMDAg/Sw0GBAQGDZGTlY+YmpyPpSQDiqYiDQoCliqZBqkGAgKIS5kEjQ21VwCyp76dBHiNvz+MR74AqSOdVwbQuo+abppo10ssjdkAnc0rf8vgl8YqIQAh+QQJBwAAACwAAAAAGAAYAAAFrCAgjiQgCGVaDgZZFCQxqKNRKGOSjMjR0qLXTyciHA7AkaLACMIAiwOC1iAxCrMToHHYjWQiA4NBEA0Q1RpWxHg4cMXxNDk4OBxNUkPAQAEXDgllKgMzQA1pSYopBgonCj9JEA8REQ8QjY+RQJOVl4ugoYssBJuMpYYjDQSliwasiQOwNakALKqsqbWvIohFm7V6rQAGP6+JQLlFg7KDQLKJrLjBKbvAor3IKiEAIfkECQcAAAAsAAAAABgAGAAABbUgII4koChlmhokw5DEoI4NQ4xFMQoJO4uuhignMiQWvxGBIQC+AJBEUyUcIRiyE6CR0CllW4HABxBURTUw4nC4FcWo5CDBRpQaCoF7VjgsyCUDYDMNZ0mHdwYEBAaGMwwHDg4HDA2KjI4qkJKUiJ6faJkiA4qAKQkRB3E0i6YpAw8RERAjA4tnBoMApCMQDhFTuySKoSKMJAq6rD4GzASiJYtgi6PUcs9Kew0xh7rNJMqIhYchACH5BAkHAAAALAAAAAAYABgAAAW0ICCOJEAQZZo2JIKQxqCOjWCMDDMqxT2LAgELkBMZCoXfyCBQiFwiRsGpku0EshNgUNAtrYPT0GQVNRBWwSKBMp98P24iISgNDAS4ipGA6JUpA2WAhDR4eWM/CAkHBwkIDYcGiTOLjY+FmZkNlCN3eUoLDmwlDW+AAwcODl5bYl8wCVYMDw5UWzBtnAANEQ8kBIM0oAAGPgcREIQnVloAChEOqARjzgAQEbczg8YkWJq8nSUhACH5BAkHAAAALAAAAAAYABgAAAWtICCOJGAYZZoOpKKQqDoORDMKwkgwtiwSBBYAJ2owGL5RgxBziQQMgkwoMkhNqAEDARPSaiMDFdDIiRSFQowMXE8Z6RdpYHWnEAWGPVkajPmARVZMPUkCBQkJBQINgwaFPoeJi4GVlQ2Qc3VJBQcLV0ptfAMJBwdcIl+FYjALQgimoGNWIhAQZA4HXSpLMQ8PIgkOSHxAQhERPw7ASTSFyCMMDqBTJL8tf3y2fCEAIfkECQcAAAAsAAAAABgAGAAABa8gII4k0DRlmg6kYZCoOg5EDBDEaAi2jLO3nEkgkMEIL4BLpBAkVy3hCTAQKGAznM0AFNFGBAbj2cA9jQixcGZAGgECBu/9HnTp+FGjjezJFAwFBQwKe2Z+KoCChHmNjVMqA21nKQwJEJRlbnUFCQlFXlpeCWcGBUACCwlrdw8RKGImBwktdyMQEQciB7oACwcIeA4RVwAODiIGvHQKERAjxyMIB5QlVSTLYLZ0sW8hACH5BAkHAAAALAAAAAAYABgAAAW0ICCOJNA0ZZoOpGGQrDoOBCoSxNgQsQzgMZyIlvOJdi+AS2SoyXrK4umWPM5wNiV0UDUIBNkdoepTfMkA7thIECiyRtUAGq8fm2O4jIBgMBA1eAZ6Knx+gHaJR4QwdCMKBxEJRggFDGgQEREPjjAMBQUKIwIRDhBDC2QNDDEKoEkDoiMHDigICGkJBS2dDA6TAAnAEAkCdQ8ORQcHTAkLcQQODLPMIgIJaCWxJMIkPIoAt3EhACH5BAkHAAAALAAAAAAYABgAAAWtICCOJNA0ZZoOpGGQrDoOBCoSxNgQsQzgMZyIlvOJdi+AS2SoyXrK4umWHM5wNiV0UN3xdLiqr+mENcWpM9TIbrsBkEck8oC0DQqBQGGIz+t3eXtob0ZTPgNrIwQJDgtGAgwCWSIMDg4HiiUIDAxFAAoODwxDBWINCEGdSTQkCQcoegADBaQ6MggHjwAFBZUFCm0HB0kJCUy9bAYHCCPGIwqmRq0jySMGmj6yRiEAIfkECQcAAAAsAAAAABgAGAAABbIgII4k0DRlmg6kYZCsOg4EKhLE2BCxDOAxnIiW84l2L4BLZKipBopW8XRLDkeCiAMyMvQAA+uON4JEIo+vqukkKQ6RhLHplVGN+LyKcXA4Dgx5DWwGDXx+gIKENnqNdzIDaiMECwcFRgQCCowiCAcHCZIlCgICVgSfCEMMnA0CXaU2YSQFoQAKUQMMqjoyAglcAAyBAAIMRUYLCUkFlybDeAYJryLNk6xGNCTQXY0juHghACH5BAkHAAAALAAAAAAYABgAAAWzICCOJNA0ZVoOAmkY5KCSSgSNBDE2hDyLjohClBMNij8RJHIQvZwEVOpIekRQJyJs5AMoHA+GMbE1lnm9EcPhOHRnhpwUl3AsknHDm5RN+v8qCAkHBwkIfw1xBAYNgoSGiIqMgJQifZUjBhAJYj95ewIJCQV7KYpzBAkLLQADCHOtOpY5PgNlAAykAEUsQ1wzCgWdCIdeArczBQVbDJ0NAqyeBb64nQAGArBTt8R8mLuyPyEAOw==\" data-src=\"//www.igtx.top/images/enable-https-banner.png\" alt=\"\" /\u003e\u003c/p\u003e\n","title":"如何免费的让网站启用HTTPS"},{"content":"\r\n\u003e文中用到的几个词：\r\n**songid** *在分享链接时出现在链接中*\r\n**vkey** *拿到音乐地址所必须的参数*\r\n**songmid** *获取vkey的音乐id*\r\n**filename** *由songid拼接而成，C100{songmid}.m4a*\r\n最终音乐地址 http://dl.stream.qqmusic.qq.com/{filename}?vkey={vkey}\u0026fromtag=66\r\n\r\n### 1 . [点击分享链接](#1)\r\n\r\n \u003cspan id=\"1\"\u003e在音乐界面点击`复制链接` 得到原始URL\u003c/span\u003e https://i.y.qq.com/v8/playsong.html?songid=212877966\u0026source=yqq#wechat_redirect \r\n得到**songid**=212877966\r\n\r\n如果在排行榜页面点击歌曲名称，例如https://y.qq.com/n/yqq/song/002Fjdnk0zz1T6.html，那么songmid就是002Fjdnk0zz1T6，可直接到第四步\r\n\r\n### 2 . [请求qq音乐接口](#2)\r\n \u003cspan id=\"2\"\u003e根据\u003c/span\u003esongid请求jsonp请求 https://c.y.qq.com/v8/fcg-bin/fcg_play_single_song.fcg?songid=212891616\u0026tpl=yqq_song_detail\u0026format=jsonp\u0026callback=getOneSongInfoCallback\r\n去掉无用的数据如下：\r\n``` jsonp\r\ngetOneSongInfoCallback({\r\n\t\"code\": 0,\r\n\t\"data\": [{\r\n\t\t...\r\n\t\t\"mid\": \"0018jCvj3i0f3E\",\r\n\t\t...\t\t\r\n\t\t\"url\": \"http://stream3.qqmusic.qq.com/224891616.wma\"\r\n\t\t\r\n\t}],\r\n\t\"url\": {\r\n\t\t\"212891616\": \"ws.stream.qqmusic.qq.com/C1000018jCvj3i0f3E.m4a?fromtag=38\"\r\n\t},\r\n\t...\r\n})\r\n```\r\n### 3 . ~~[拿到最终地址](#3)~~\r\n**04.19发现地址已经被屏蔽403，继续步骤4**\r\n ~~获取mid，拼装URL http://thirdparty.gtimg.com/C100{mid}.m4a?fromtag={random} 得到最终音乐文件地址~~\r\n此方法已不能用，提示未授权。\r\n\r\n~~\u003cspan id=\"3\"\u003e改为直接读取步骤2中的json url: **ws.stream.qqmusic.qq.com/C1000018jCvj3i0f3E.m4a?fromtag=38**\u003c/span\u003e~~\r\n*****\r\n\r\n### 4. 请求音乐文件的vkey\r\n\r\n在播放页面抓取js得到如下地址：\r\nhttps://c.y.qq.com/base/fcgi-bin/fcg_music_express_mobile3.fcg?g_tk=872989112\u0026jsonpCallback=MusicJsonCallback06459212607938936\u0026hostUin=0\u0026format=json\u0026inCharset=utf8\u0026outCharset=utf-8\u0026notice=0\u0026platform=yqq\u0026needNewCode=0\u0026cid=205361747\u0026callback=MusicJsonCallback06459212607938936\u0026uin=11297258\u0026songmid=0018jCvj3i0f3E\u0026filename=C1000018jCvj3i0f3E.m4a\u0026guid=9136027940\r\n\r\n\u003csmall\u003e链接有些长，应该有无效的参数，暂未验证哪些参数是必须传的\u003c/small\u003e\r\n\r\n需要替换里面的**songmid**、**filename**\r\n其中参数**songmid**就是步骤2中的mid（ps: 里面有好几个mid，最外层的那个，**filename**=*C100{songmid}.m4a*）\r\n\r\n\r\n之后后请求，得到json，拿到vkey：\r\n``` json\r\n{\r\n    \"code\": 0,  \r\n    \"data\": {\r\n        \"expiration\": 80400,\r\n        \"items\": [\r\n            {\r\n                \"subcode\": 0,\r\n                \"songmid\": \"0018jCvj3i0f3E\",\r\n                \"filename\": \"C1000018jCvj3i0f3E.m4a\",\r\n                \"vkey\": \"734C6EF27F122751D9D098AC84F2465F8BA2658A4D4EC9C6A084FCDC10C68718A5C72869CF3B424EC4EE8CCF96FEFDD4E2B2F7F9E6790E73\"\r\n            }\r\n        ]\r\n    }\r\n}\r\n```\r\n里面的expiration猜测是vkey的过期时间\r\n### 5. 拼接最终地址\r\n用步骤4里面的数据filename、vkey拼接下面地址：\r\n\u003ehttp://dl.stream.qqmusic.qq.com/**{filename}**?vkey=**{vkey}**\u0026fromtag=66\r\n\r\n### 6. 批量下载qq音乐脚本\r\n``` python\r\n#!/usr/bin/python\r\n# -*- coding: UTF-8 -*-\r\n\r\nimport requests,json,re\r\nfrom selenium import webdriver\r\nfrom selenium.webdriver.common.by import By\r\nfrom selenium.webdriver.support.ui import WebDriverWait\r\nfrom selenium.webdriver.support import expected_conditions as EC\r\n\r\nfrom multiprocessing import Pool\r\n\r\ndef download_music(songmid,music_name):\r\n    url='https://c.y.qq.com/base/fcgi-bin/fcg_music_express_mobile3.fcg?g_tk=872989112\u0026jsonpCallback=MusicJsonCallback06459212607938936\u0026loginUin=11297258\u0026hostUin=0\u0026format=json\u0026inCharset=utf8\u0026outCharset=utf-8\u0026notice=0\u0026platform=yqq\u0026needNewCode=0\u0026cid=205361747\u0026callback=MusicJsonCallback06459212607938936\u0026uin=11297258\u0026songmid={0}\u0026filename=C100{0}.m4a\u0026guid=9136027940'.format(songmid)\r\n    html= requests.get(url)\r\n    # 去掉jsonp\r\n    music_json= json.loads(re.findall(r'^\\w+\\((.*)\\)$',html.text)[0])\r\n    filename=music_json['data']['items'][0]['filename']\r\n    vkey=music_json['data']['items'][0]['vkey']\r\n    download_url='http://dl.stream.qqmusic.qq.com/{}?vkey={}\u0026fromtag=66'.format(filename,vkey)\r\n    print(download_url)\r\n    #下载到本地\r\n    music=requests.get(download_url)\r\n    #文件名去除特殊符号\r\n    with open(\"d:\\\\music\\\\{}.m4a\".format( re.sub(r'[\\s+|@\u003c\u003e:\\\\\"/]','',music_name)),\"wb\") as m:\r\n         m.write(music.content)\r\n\r\ndef view_html():\r\n    # qq音乐页面是js加载的，这里用chrome headless模式访问\r\n    option = webdriver.ChromeOptions()\r\n    option.add_argument('headless')\r\n    driver = webdriver.Chrome('D:\\Program Files\\Python\\chromedriver.exe',chrome_options=option)\r\n\r\n    #排行榜页面\r\n    driver.get('https://y.qq.com/n/yqq/toplist/26.html')\r\n    print(driver.title)\r\n    try:\r\n        # 等待播放列表加载完毕\r\n        WebDriverWait(driver, 10).until(EC.presence_of_element_located((By.CLASS_NAME, \"songlist__songname_txt\")))\r\n\r\n        lis= driver.find_elements_by_class_name('songlist__songname_txt')  \r\n        pattern = re.compile(r'https://y.qq.com/n/yqq/song/(\\S+).html')    \r\n        for i in range(lis.__len__()):\r\n            li = lis.__getitem__(i)\r\n            a= li.find_element_by_class_name('js_song')\r\n            # 获得songid\r\n            href=a.get_attribute('href') \r\n            music_name=a.get_attribute('title')          \r\n            m=pattern.match(href)            \r\n            download_music(m.group(1),music_name)\r\n       \r\n    finally:\r\n        driver.quit()\r\n \r\n\r\nif __name__ == '__main__':\r\n    view_html()\r\n```    \r\n效果图如下：\r\n![抓取的页面](https://img-blog.csdn.net/20180704114411994?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpanVuaHVhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\r\n\r\n![运行的代码](https://img-blog.csdn.net/20180704114432259?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpanVuaHVhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\r\n\r\n![保存的音乐](https://img-blog.csdn.net/201807041144425?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpanVuaHVhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\r\n","cover":"","link":"qq音乐抓取.html","preview":"\u003cp\u003e拿到有过期时间的地址，要尽快下载\u003c/p\u003e\n","title":"抓取qq音乐原始播放地址"},{"content":"\r\n\r\n[TOC]\r\n## 最终效果图\r\n![这里写图片描述](https://img-blog.csdn.net/20180515231231236?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpanVuaHVhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\r\n\r\n## 美化步骤\r\n\r\n### 1.gnome tweak tool 安装[^1]\r\n\r\n```\r\nsudo apt-get install gnome-tweak-tool\r\n```\r\n\r\n### 2.gnome shell 安装[^2]\r\n安装使用主题必备的扩展user themes ，[地址](https://extensions.gnome.org/extension/19/user-themes/)\r\n\r\n\r\n----------\r\n其他扩展推荐：\r\n![](https://img-blog.csdn.net/20180515233124798?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpanVuaHVhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\r\n\r\n### 3.主题下载\r\n使用的是mac osc，[地址：https://www.gnome-look.org/p/1171688/](https://www.gnome-look.org/p/1171688/)\r\n这里我打包好了，包括壁纸、图标、shell，[下载地址](https://download.csdn.net/download/lijunhuan/10416872)\r\n\r\n### 4.安装主题\r\n我的是在当前用户下创建的主题，所以只对当前用户有效，在**/home/{你的名字}** 下面创建**.icons** 、**.themes** 文件夹\r\n.icons放置的是图标，.themes里面放的是主题和Shell。\r\n我打包的可直接在目录下解压即可，然后打开tweak tool（名字显示叫调试），在外观下选择下图对应的即可\r\n\r\n![这里写图片描述](https://img-blog.csdn.net/20180515235142277?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpanVuaHVhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\r\n### 5.标题栏按钮放左边\r\n点击 “窗口”——“标题栏按钮”——“左”\r\n\r\n![图](https://img-blog.csdn.net/20180516231143128?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpanVuaHVhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\r\n大功告成\r\n\r\n[^1]:[https://pkgs.org/download/gnome-tweak-tool](https://pkgs.org/download/gnome-tweak-tool)\r\n\r\n[^2]:[https://extensions.gnome.org/#](https://extensions.gnome.org/#)\r\n\r\n","cover":"","link":"ubuntu18仿mac.html","preview":"\u003cp\u003e一直在模仿，从未被超越\u003c/p\u003e\n","title":"Ubuntu18.04仿mac"},{"content":"\r\n\r\n\r\n本Markdown编辑器使用[StackEdit][6]修改而来，用它写博客，将会带来全新的体验哦：\r\n\r\n- **Markdown和扩展Markdown简洁的语法**\r\n- **代码块高亮**\r\n- **图片链接和图片上传**\r\n- **LaTex*数学公式**\r\n- **UML序列图和流程图**\r\n- **离线写博客**\r\n- **导入导出Markdown文件**\r\n- **丰富的快捷键**\r\n\r\n-------------------\r\n\r\n## 快捷键\r\n\r\n - 加粗    `Ctrl + B` \r\n - 斜体    `Ctrl + I` \r\n - 引用    `Ctrl + Q`\r\n - 插入链接    `Ctrl + L`\r\n - 插入代码    `Ctrl + K`\r\n - 插入图片    `Ctrl + G`\r\n - 提升标题    `Ctrl + H`\r\n - 有序列表    `Ctrl + O`\r\n - 无序列表    `Ctrl + U`\r\n - 横线    `Ctrl + R`\r\n - 撤销    `Ctrl + Z`\r\n - 重做    `Ctrl + Y`\r\n\r\n## Markdown及扩展\r\n\r\n\u003e Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。    —— \u003ca href=\"https://zh.wikipedia.org/wiki/Markdown\" target=\"_blank\"\u003e [ 维基百科 ]\r\n\r\n使用简单的符号标识不同的标题，将某些文字标记为**粗体**或者*斜体*，创建一个[链接](http://www.csdn.net)等，详细语法参考帮助？。\r\n\r\n本编辑器支持 **Markdown Extra** , 　扩展了很多好用的功能。具体请参考[Github][2].  \r\n\r\n### 表格\r\n\r\n**Markdown　Extra**　表格语法：\r\n\r\n项目     | 价格\r\n-------- | ---\r\nComputer | $1600\r\nPhone    | $12\r\nPipe     | $1\r\n\r\n可以使用冒号来定义对齐方式：\r\n\r\n| 项目      |    价格 | 数量  |\r\n| :-------- | --------:| :--: |\r\n| Computer  | 1600 元 |  5   |\r\n| Phone     |   12 元 |  12  |\r\n| Pipe      |    1 元 | 234  |\r\n\r\n### 定义列表\r\n\r\n**Markdown　Extra**　定义列表语法：\r\n项目１\r\n项目２\r\n:   定义 A\r\n:   定义 B\r\n\r\n### 代码块\r\n代码块语法遵循标准markdown代码，例如：\r\n\r\n```python\r\n@requires_authorization\r\ndef somefunc(param1='', param2=0):\r\n    '''A docstring'''\r\n    if param1 \u003e param2: # interesting\r\n        print 'Greater'\r\n    return (param2 - param1 + 1) or None\r\nclass SomeClass:\r\n    pass\r\n\u003e\u003e\u003e message = '''interpreter\r\n... prompt'''\r\n```\r\n\r\n### 脚注\r\n生成一个脚注[^footnote].\r\n  [^footnote]: 这里是 **脚注** 的 *内容*.\r\n  \r\n### 目录\r\n用 `[TOC]`来生成目录：\r\n\r\n[TOC]\r\n\r\n### 数学公式\r\n使用MathJax渲染*LaTex* 数学公式，详见[math.stackexchange.com][1].\r\n\r\n - 行内公式，数学公式为：$\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$。\r\n - 块级公式：\r\n\r\n$$\tx = \\dfrac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} $$\r\n\r\n更多LaTex语法请参考 [这儿][3].\r\n\r\n### UML 图:\r\n\r\n可以渲染序列图：\r\n\r\n```sequence\r\n张三-\u003e李四: 嘿，小四儿, 写博客了没?\r\nNote right of 李四: 李四愣了一下，说：\r\n李四--\u003e张三: 忙得吐血，哪有时间写。\r\n```\r\n\r\n或者流程图：\r\n\r\n```flow\r\nst=\u003estart: 开始\r\ne=\u003eend: 结束\r\nop=\u003eoperation: 我的操作\r\ncond=\u003econdition: 确认？\r\n\r\nst-\u003eop-\u003econd\r\ncond(yes)-\u003ee\r\ncond(no)-\u003eop\r\n```\r\n\r\n- 关于 **序列图** 语法，参考 [这儿][4],\r\n- 关于 **流程图** 语法，参考 [这儿][5].\r\n\r\n## 离线写博客\r\n\r\n即使用户在没有网络的情况下，也可以通过本编辑器离线写博客（直接在曾经使用过的浏览器中输入[write.blog.csdn.net/mdeditor](http://write.blog.csdn.net/mdeditor)即可。**Markdown编辑器**使用浏览器离线存储将内容保存在本地。\r\n\r\n用户写博客的过程中，内容实时保存在浏览器缓存中，在用户关闭浏览器或者其它异常情况下，内容不会丢失。用户再次打开浏览器时，会显示上次用户正在编辑的没有发表的内容。\r\n\r\n博客发表后，本地缓存将被删除。　\r\n\r\n用户可以选择 \u003ci class=\"icon-disk\"\u003e\u003c/i\u003e 把正在写的博客保存到服务器草稿箱，即使换浏览器或者清除缓存，内容也不会丢失。\r\n\r\n\u003e **注意：**虽然浏览器存储大部分时候都比较可靠，但为了您的数据安全，在联网后，**请务必及时发表或者保存到服务器草稿箱**。\r\n\r\n##浏览器兼容\r\n\r\n 1. 目前，本编辑器对Chrome浏览器支持最为完整。建议大家使用较新版本的Chrome。\r\n 3. IE９以下不支持\r\n 4. IE９，１０，１１存在以下问题\r\n    1. 不支持离线功能\r\n    1. IE9不支持文件导入导出\r\n    1. IE10不支持拖拽文件导入\r\n\r\n---------\r\n\r\n[1]: http://math.stackexchange.com/\r\n[2]: https://github.com/jmcmanus/pagedown-extra \"Pagedown Extra\"\r\n[3]: http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference\r\n[4]: http://bramp.github.io/js-sequence-diagrams/\r\n[5]: http://adrai.github.io/flowchart.js/\r\n[6]: https://github.com/benweet/stackedit\r\n","cover":"","link":"msdnmarkdown.html","preview":"\u003cp\u003e本Markdown编辑器使用[StackEdit][6]修改而来，用它写博客，将会带来全新的体验哦：\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eMarkdown和扩展Markdown简洁的语法\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e代码块高亮\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e图片链接和图片上传\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eLaTex*数学公式\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eUML序列图和流程图\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e离线写博客\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e导入导出Markdown文件\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e丰富的快捷键\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003chr /\u003e\n","title":"欢迎使用Markdown编辑器写博客"}]